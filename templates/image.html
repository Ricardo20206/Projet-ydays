{% extends "base.html" %}

{% block content %}
<script>
    window.currentMedia = {
        video: null,
        // eslint-disable-next-line
        image: {{ image|default('null')|tojson }}
    };
    
    // Initialiser window.addedElements au d√©but pour qu'il soit toujours disponible
    if (!window.addedElements) {
        window.addedElements = [];
    }
    
    // Initialiser le flag pour √©viter la r√©cursion dans selectShape
    if (typeof window.isSelectingShape === 'undefined') {
        window.isSelectingShape = false;
    }
    
    // D√©finir toggleToolsMenu AVANT tout le reste pour qu'elle soit accessible
    window.toggleToolsMenu = function() {
        console.log('=== toggleToolsMenu appel√© ===');
        try {
            const menu = document.getElementById('toolsMenu');
            const overlay = document.getElementById('toolsOverlay');
            
            console.log('Menu trouv√©:', menu);
            console.log('Overlay trouv√©:', overlay);
            
            if (!menu) {
                console.error('ERREUR: Menu toolsMenu non trouv√© dans le DOM');
                alert('Menu non trouv√©. V√©rifiez la console pour plus de d√©tails.');
                return;
            }
            
            // Cr√©er l'overlay s'il n'existe pas
            let currentOverlay = overlay;
            if (!currentOverlay) {
                console.log('Cr√©ation de l\'overlay...');
                currentOverlay = document.createElement('div');
                currentOverlay.id = 'toolsOverlay';
                currentOverlay.className = 'tools-overlay';
                currentOverlay.onclick = window.toggleToolsMenu;
                document.body.appendChild(currentOverlay);
            }
            
            // V√©rifier l'√©tat r√©el du menu en regardant la position right et le display
            const computedStyle = window.getComputedStyle(menu);
            const currentRight = menu.style.right || computedStyle.right;
            const currentDisplay = menu.style.display || computedStyle.display;
            const isMenuVisible = (currentRight === '0px' || currentRight === '0') && 
                                 (currentDisplay === 'flex' || currentDisplay === 'block') &&
                                 menu.classList.contains('active');
            
            console.log('Position actuelle du menu:', currentRight);
            console.log('Display actuel:', currentDisplay);
            console.log('Menu visible:', isMenuVisible);
            
            if (isMenuVisible) {
                // Fermer le menu
                console.log('Fermeture du menu...');
                menu.classList.remove('active');
                menu.style.setProperty('right', '-400px', 'important');
                menu.style.setProperty('display', 'none', 'important');
                
                if (currentOverlay) {
                    currentOverlay.classList.remove('active');
                    currentOverlay.style.setProperty('display', 'none', 'important');
                }
                
                // Fermer tous les sous-menus
                document.querySelectorAll('.shapes-submenu').forEach(submenu => {
                    submenu.classList.remove('active');
                    submenu.style.setProperty('right', '-400px', 'important');
                    submenu.style.setProperty('display', 'none', 'important');
                });
                
                // R√©activer le canvas
                if (window.canvas) {
                    window.canvas.style.pointerEvents = 'auto';
                    window.canvas.style.zIndex = '100';
                }
                
                console.log('Menu ferm√©');
            } else {
                // Ouvrir le menu - FORCER l'ouverture avec tous les styles n√©cessaires
                console.log('Ouverture du menu...');
                
                // Fermer d'abord tous les sous-menus pour √©viter les conflits
                document.querySelectorAll('.shapes-submenu').forEach(submenu => {
                    submenu.classList.remove('active');
                    submenu.style.setProperty('right', '-400px', 'important');
                    submenu.style.setProperty('display', 'none', 'important');
                });
                
                // D√©sactiver le canvas si il existe
                if (window.canvas) {
                    window.canvas.style.pointerEvents = 'none';
                    window.canvas.style.zIndex = '50';
                }
                
                // Appliquer TOUS les styles n√©cessaires avec !important pour garantir la visibilit√©
                menu.classList.add('active');
                menu.style.setProperty('display', 'flex', 'important');
                menu.style.setProperty('visibility', 'visible', 'important');
                menu.style.setProperty('opacity', '1', 'important');
                menu.style.setProperty('right', '0', 'important');
                menu.style.setProperty('z-index', '2000', 'important');
                menu.style.setProperty('position', 'fixed', 'important');
                menu.style.setProperty('top', '0', 'important');
                menu.style.setProperty('width', '350px', 'important');
                menu.style.setProperty('height', '100vh', 'important');
                menu.style.setProperty('background', 'white', 'important');
                
                if (currentOverlay) {
                    currentOverlay.classList.add('active');
                    currentOverlay.style.setProperty('z-index', '1999', 'important');
                    currentOverlay.style.setProperty('display', 'block', 'important');
                    currentOverlay.style.setProperty('position', 'fixed', 'important');
                    currentOverlay.style.setProperty('top', '0', 'important');
                    currentOverlay.style.setProperty('left', '0', 'important');
                    currentOverlay.style.setProperty('width', '100%', 'important');
                    currentOverlay.style.setProperty('height', '100%', 'important');
                    currentOverlay.style.setProperty('background', 'rgba(0, 0, 0, 0.5)', 'important');
                }
                
                console.log('Menu ouvert - Styles appliqu√©s avec !important');
            }
        } catch (error) {
            console.error('ERREUR dans toggleToolsMenu:', error);
            alert('Erreur lors de l\'ouverture du menu: ' + error.message);
        }
    };
    
    console.log('toggleToolsMenu d√©fini globalement:', typeof window.toggleToolsMenu);
    
    // D√©finir selectTool AVANT tout le reste pour qu'elle soit accessible
    window.selectTool = function(tool) {
        try {
            console.log('selectTool appel√© avec:', tool);
            
            // V√©rifier que tool est valide
            if (!tool || typeof tool !== 'string') {
                console.error('selectTool: tool invalide:', tool);
                return;
            }
            
            // Fermer tous les sous-menus d'abord de mani√®re s√©curis√©e
            try {
                const allSubmenus = document.querySelectorAll('.shapes-submenu');
                if (allSubmenus && allSubmenus.length > 0) {
                    allSubmenus.forEach(submenu => {
                        try {
                            if (submenu) {
                                submenu.classList.remove('active');
                                submenu.style.right = '-400px';
                            }
                        } catch (e) {
                            console.warn('Erreur lors de la fermeture d\'un sous-menu:', e);
                        }
                    });
                }
            } catch (e) {
                console.warn('Erreur lors de la fermeture des sous-menus:', e);
            }
            
            // Cacher le menu principal temporairement pour laisser place au sous-menu
            try {
                const mainMenu = document.getElementById('toolsMenu');
                if (mainMenu) {
                    mainMenu.style.right = '-400px';
                }
            } catch (e) {
                console.warn('Erreur lors de la fermeture du menu principal:', e);
            }
            
            // D√©sactiver le canvas imm√©diatement pour √©viter qu'il bloque les clics
            try {
                const canvas = document.getElementById('editingCanvas');
                if (canvas) {
                    canvas.style.pointerEvents = 'none';
                    canvas.style.zIndex = '50';
                }
            } catch (e) {
                console.warn('Erreur lors de la d√©sactivation du canvas:', e);
            }
            
            // Attendre un peu avant d'ouvrir le sous-menu pour l'animation
            setTimeout(() => {
                try {
                    // Ouvrir le sous-menu correspondant
                    if (tool === 'formes') {
                        const shapesMenu = document.getElementById('shapesSubmenu');
                        if (shapesMenu) {
                            shapesMenu.classList.add('active');
                            shapesMenu.style.setProperty('right', '0', 'important');
                            shapesMenu.style.setProperty('display', 'flex', 'important');
                            shapesMenu.style.setProperty('visibility', 'visible', 'important');
                            shapesMenu.style.setProperty('opacity', '1', 'important');
                            shapesMenu.style.setProperty('z-index', '2001', 'important');
                            console.log('‚úÖ Sous-menu Formes ouvert');
                        } else {
                            console.error('‚ùå Sous-menu Formes non trouv√© dans le DOM');
                            alert('Erreur: Le sous-menu Formes n\'a pas √©t√© trouv√©. Veuillez recharger la page.');
                        }
                    } else if (tool === 'lignes') {
                        const linesMenu = document.getElementById('linesSubmenu');
                        if (linesMenu) {
                            linesMenu.classList.add('active');
                            linesMenu.style.setProperty('right', '0', 'important');
                            linesMenu.style.setProperty('display', 'flex', 'important');
                            linesMenu.style.setProperty('visibility', 'visible', 'important');
                            linesMenu.style.setProperty('opacity', '1', 'important');
                            linesMenu.style.setProperty('z-index', '2001', 'important');
                            console.log('‚úÖ Sous-menu Lignes ouvert');
                        } else {
                            console.error('‚ùå Sous-menu Lignes non trouv√© dans le DOM');
                            alert('Erreur: Le sous-menu Lignes n\'a pas √©t√© trouv√©. Veuillez recharger la page.');
                        }
                    } else if (tool === 'dessin') {
                        const drawMenu = document.getElementById('drawSubmenu');
                        if (drawMenu) {
                            drawMenu.classList.add('active');
                            drawMenu.style.setProperty('right', '0', 'important');
                            drawMenu.style.setProperty('display', 'flex', 'important');
                            drawMenu.style.setProperty('visibility', 'visible', 'important');
                            drawMenu.style.setProperty('opacity', '1', 'important');
                            drawMenu.style.setProperty('z-index', '2001', 'important');
                            console.log('‚úÖ Sous-menu Dessin ouvert');
                        } else {
                            console.error('‚ùå Sous-menu Dessin non trouv√© dans le DOM');
                            alert('Erreur: Le sous-menu Dessin n\'a pas √©t√© trouv√©. Veuillez recharger la page.');
                        }
                    } else {
                        console.warn('selectTool: tool non reconnu:', tool);
                    }
                } catch (error) {
                    console.error('Erreur dans setTimeout de selectTool:', error);
                    console.error('Stack trace:', error.stack);
                    alert('Erreur lors de l\'ouverture du sous-menu: ' + error.message);
                }
            }, 100);
        } catch (error) {
            console.error('Erreur critique dans selectTool:', error);
            console.error('Stack trace:', error.stack);
            alert('Erreur critique: ' + error.message + '\nVeuillez recharger la page.');
        }
    };
    
    console.log('selectTool d√©fini globalement:', typeof window.selectTool);
    
    // S'assurer que selectTool est accessible globalement m√™me apr√®s le chargement
    if (typeof window.selectTool !== 'function') {
        console.error('ERREUR: window.selectTool n\'a pas √©t√© correctement d√©finie!');
    }
    
    // D√©finir les fonctions de fermeture des sous-menus AVANT tout le reste
    window.closeShapesSubmenu = function() {
        console.log('Fermeture du sous-menu Formes');
        const shapesMenu = document.getElementById('shapesSubmenu');
        if (shapesMenu) {
            shapesMenu.classList.remove('active');
            shapesMenu.style.right = '-400px';
        }
        // R√©afficher le menu principal
        const mainMenu = document.getElementById('toolsMenu');
        if (mainMenu) {
            mainMenu.style.right = '0';
            mainMenu.style.display = 'flex';
            mainMenu.style.visibility = 'visible';
            mainMenu.style.opacity = '1';
            mainMenu.style.zIndex = '2000';
            console.log('Menu principal r√©affich√©');
        } else {
            console.error('Menu principal non trouv√©');
        }
        if (typeof currentShape !== 'undefined') {
            currentShape = null;
        }
    };
    
    window.closeLinesSubmenu = function() {
        console.log('Fermeture du sous-menu Lignes');
        const linesMenu = document.getElementById('linesSubmenu');
        if (linesMenu) {
            linesMenu.classList.remove('active');
            linesMenu.style.right = '-400px';
        }
        // R√©afficher le menu principal
        const mainMenu = document.getElementById('toolsMenu');
        if (mainMenu) {
            mainMenu.style.right = '0';
            mainMenu.style.display = 'flex';
            mainMenu.style.visibility = 'visible';
            mainMenu.style.opacity = '1';
            mainMenu.style.zIndex = '2000';
            console.log('Menu principal r√©affich√©');
        } else {
            console.error('Menu principal non trouv√©');
        }
        if (typeof currentLineType !== 'undefined') {
            currentLineType = null;
        }
    };
    
    window.closeTextSubmenu = function() {
        console.log('Fermeture du sous-menu Texte');
        const textMenu = document.getElementById('textSubmenu');
        if (textMenu) {
            textMenu.classList.remove('active');
            textMenu.style.right = '-400px';
        }
        // R√©afficher le menu principal
        const mainMenu = document.getElementById('toolsMenu');
        if (mainMenu) {
            mainMenu.style.right = '0';
            mainMenu.style.display = 'flex';
            mainMenu.style.visibility = 'visible';
            mainMenu.style.opacity = '1';
            mainMenu.style.zIndex = '2000';
            console.log('Menu principal r√©affich√©');
        } else {
            console.error('Menu principal non trouv√©');
        }
    };
    
    window.closeDrawSubmenu = function() {
        console.log('Fermeture du sous-menu Dessin');
        const drawMenu = document.getElementById('drawSubmenu');
        if (drawMenu) {
            drawMenu.classList.remove('active');
            drawMenu.style.right = '-400px';
        }
        // R√©afficher le menu principal
        const mainMenu = document.getElementById('toolsMenu');
        if (mainMenu) {
            mainMenu.style.right = '0';
            mainMenu.style.display = 'flex';
            mainMenu.style.visibility = 'visible';
            mainMenu.style.opacity = '1';
            mainMenu.style.zIndex = '2000';
            console.log('Menu principal r√©affich√©');
        } else {
            console.error('Menu principal non trouv√©');
        }
    };
    
    console.log('Fonctions de fermeture d√©finies globalement');
    
    // D√©finir drawShape AVANT selectShape pour qu'elle soit accessible
    window.drawShape = function(shapeType, x, y, width, height, elementId = null) {
        console.log('drawShape appel√©:', {shapeType, x, y, width, height, elementId});
        
        try {
            // Essayer d'obtenir le contexte de plusieurs fa√ßons
            let currentCtx = window.ctx;
            let currentCanvas = window.canvas;
            
            // Si le contexte n'est pas disponible, essayer de le r√©cup√©rer
            if (!currentCtx) {
                // Essayer de r√©cup√©rer le canvas
                if (!currentCanvas) {
                    currentCanvas = document.getElementById('editingCanvas');
                    if (currentCanvas) {
                        window.canvas = currentCanvas;
                    }
                }
                
                // Si on a le canvas, obtenir le contexte
                if (currentCanvas) {
                    currentCtx = currentCanvas.getContext('2d');
                    if (currentCtx) {
                        window.ctx = currentCtx;
                    }
                }
            }
            
            // Si toujours pas de contexte, erreur
            if (!currentCtx) {
                console.error('Contexte canvas non disponible pour dessiner la forme');
                console.log('window.ctx:', window.ctx);
                console.log('window.canvas:', window.canvas);
                return null;
            }
            
            // V√©rifier que le canvas a une taille valide
            if (currentCanvas && (currentCanvas.width === 0 || currentCanvas.height === 0)) {
                currentCanvas.width = window.innerWidth || 1920;
                currentCanvas.height = window.innerHeight || 1080;
                console.log('Canvas redimensionn√© dans drawShape:', currentCanvas.width, 'x', currentCanvas.height);
            }
            
            console.log('Contexte disponible, dessin de la forme...');
            
            const id = elementId || 'shape_' + Date.now();
            
            // Sauvegarder l'√©tat du contexte
            currentCtx.save();
            
            // Toutes les formes en jaune (or) - couleur jaune vif
            currentCtx.strokeStyle = '#FFD700';
            currentCtx.fillStyle = 'rgba(255, 215, 0, 0.3)';
            currentCtx.lineWidth = 3;
            
            switch(shapeType) {
            case 'square':
                currentCtx.fillRect(x, y, width, height);
                currentCtx.strokeRect(x, y, width, height);
                break;
                
            case 'rounded-square':
                const radius = Math.min(width, height) * 0.2;
                currentCtx.beginPath();
                currentCtx.moveTo(x + radius, y);
                currentCtx.lineTo(x + width - radius, y);
                currentCtx.quadraticCurveTo(x + width, y, x + width, y + radius);
                currentCtx.lineTo(x + width, y + height - radius);
                currentCtx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                currentCtx.lineTo(x + radius, y + height);
                currentCtx.quadraticCurveTo(x, y + height, x, y + height - radius);
                currentCtx.lineTo(x, y + radius);
                currentCtx.quadraticCurveTo(x, y, x + radius, y);
                currentCtx.closePath();
                currentCtx.fill();
                currentCtx.stroke();
                break;
                
            case 'circle':
                const centerX = x + width / 2;
                const centerY = y + height / 2;
                const radius_circle = Math.min(width, height) / 2;
                currentCtx.beginPath();
                currentCtx.arc(centerX, centerY, radius_circle, 0, 2 * Math.PI);
                currentCtx.fill();
                currentCtx.stroke();
                break;
                
            case 'triangle':
                currentCtx.beginPath();
                currentCtx.moveTo(x + width / 2, y);
                currentCtx.lineTo(x, y + height);
                currentCtx.lineTo(x + width, y + height);
                currentCtx.closePath();
                currentCtx.fill();
                currentCtx.stroke();
                break;
                
            case 'triangle-inverted':
                currentCtx.beginPath();
                currentCtx.moveTo(x + width / 2, y + height);
                currentCtx.lineTo(x, y);
                currentCtx.lineTo(x + width, y);
                currentCtx.closePath();
                currentCtx.fill();
                currentCtx.stroke();
                break;
                
            case 'diamond':
                currentCtx.beginPath();
                currentCtx.moveTo(x + width / 2, y);
                currentCtx.lineTo(x + width, y + height / 2);
                currentCtx.lineTo(x + width / 2, y + height);
                currentCtx.lineTo(x, y + height / 2);
                currentCtx.closePath();
                currentCtx.fill();
                currentCtx.stroke();
                break;
                
            case 'hexagon':
                const centerX_hex = x + width / 2;
                const centerY_hex = y + height / 2;
                const radius_hex = Math.min(width, height) / 2;
                currentCtx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i;
                    const px = centerX_hex + radius_hex * Math.cos(angle);
                    const py = centerY_hex + radius_hex * Math.sin(angle);
                    if (i === 0) {
                        currentCtx.moveTo(px, py);
                    } else {
                        currentCtx.lineTo(px, py);
                    }
                }
                currentCtx.closePath();
                currentCtx.fill();
                currentCtx.stroke();
                break;
                
            default:
                console.warn('Type de forme non reconnu:', shapeType);
                currentCtx.restore();
                return null;
        }
        
            // Restaurer l'√©tat du contexte
            currentCtx.restore();
            
            // NE JAMAIS ajouter d'√©l√©ment dans drawShape - cela doit √™tre fait AVANT l'appel
            // drawShape est uniquement responsable du dessin, pas de la gestion des √©l√©ments
            if (!elementId) {
                console.warn('drawShape appel√© sans elementId - l\'√©l√©ment devrait √™tre ajout√© avant');
            }
            
            console.log('‚úÖ Forme dessin√©e avec succ√®s:', {id, x, y, width, height});
            return { id, x, y, width, height };
            
        } catch (error) {
            console.error('ERREUR dans drawShape:', error);
            console.error('D√©tails:', {shapeType, x, y, width, height, elementId});
            return null;
        }
    };
    
    console.log('window.drawShape d√©fini globalement:', typeof window.drawShape);
    
    // D√©finir selectShape - VERSION ULTRA-SIMPLIFI√âE SANS R√âCURSION
    window.selectShape = function(shapeType) {
        console.log('=== selectShape appel√© avec:', shapeType);
        
        // V√âRIFICATION STRICTE - si d√©j√† en cours, IGNORER COMPL√àTEMENT
        if (window.isSelectingShape === true) {
            console.warn('selectShape d√©j√† en cours, appel ignor√©');
            return;
        }
        
        // D√©finir le flag IMM√âDIATEMENT
        window.isSelectingShape = true;
        
        // Utiliser requestAnimationFrame pour s'assurer que le DOM est pr√™t
        requestAnimationFrame(function() {
            // V√©rifier √† nouveau le flag
            if (!window.isSelectingShape) {
                console.warn('Flag d√©sactiv√©, abandon');
                return;
            }
            
            try {
                // Fermer le sous-menu
                const shapesMenu = document.getElementById('shapesSubmenu');
                if (shapesMenu) {
                    shapesMenu.style.right = '-400px';
                    shapesMenu.style.display = 'none';
                }
                const mainMenu = document.getElementById('toolsMenu');
                if (mainMenu) {
                    mainMenu.style.right = '0';
                    mainMenu.style.display = 'flex';
                }
                
                // R√©cup√©rer le canvas
                const currentCanvas = document.getElementById('editingCanvas');
                if (!currentCanvas) {
                    window.isSelectingShape = false;
                    alert('Erreur: Le canvas n\'est pas disponible.');
                    return;
                }
                
                // R√©cup√©rer le contexte
                const currentCtx = currentCanvas.getContext('2d');
                if (!currentCtx) {
                    window.isSelectingShape = false;
                    alert('Erreur: Le contexte du canvas n\'est pas disponible.');
                    return;
                }
                
                // Synchroniser avec window
                window.canvas = currentCanvas;
                window.ctx = currentCtx;
                
                // Taille du canvas
                if (currentCanvas.width === 0 || currentCanvas.height === 0) {
                    currentCanvas.width = window.innerWidth || 1920;
                    currentCanvas.height = window.innerHeight || 1080;
                }
                
                // Styles du canvas - modifications minimales
                currentCanvas.style.display = 'block';
                currentCanvas.style.visibility = 'visible';
                currentCanvas.style.opacity = '1';
                currentCanvas.style.zIndex = '1000';
                currentCanvas.style.pointerEvents = 'auto';
                
                // Obtenir l'image
                const imageElement = document.getElementById('editableImage');
                if (!imageElement) {
                    window.isSelectingShape = false;
                    alert('Image non trouv√©e.');
                    return;
                }
                
                // V√©rifier si l'image est charg√©e
                if (!imageElement.complete || imageElement.naturalWidth === 0 || imageElement.naturalHeight === 0) {
                    console.warn('Image non charg√©e, abandon');
                    window.isSelectingShape = false;
                    alert('Veuillez attendre que l\'image soit compl√®tement charg√©e.');
                    return;
                }
                
                // Position au centre du canvas (espace image) pour que la forme d√©file avec l'image
                const defaultSize = 100;
                const shapeStartX = (currentCanvas.width / 2) - defaultSize / 2;
                const shapeStartY = (currentCanvas.height / 2) - defaultSize / 2;
                
                console.log('Cr√©ation de la forme:', {shapeType, shapeStartX, shapeStartY});
                
                // Initialiser addedElements si n√©cessaire
                if (!window.addedElements) {
                    window.addedElements = [];
                }
                
                // Cr√©er l'√©l√©ment avec un ID unique
                const newElementId = 'shape_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                const newElement = {
                    type: 'shape',
                    id: newElementId,
                    shapeType: shapeType,
                    x: shapeStartX,
                    y: shapeStartY,
                    width: defaultSize,
                    height: defaultSize
                };
                
                // Ajouter √† la liste AVANT de dessiner
                window.addedElements.push(newElement);
                console.log('√âl√©ment ajout√©:', newElement);
                
                // Dessiner la forme DIRECTEMENT sur le canvas
                const shapeResult = window.drawShape(shapeType, shapeStartX, shapeStartY, defaultSize, defaultSize, newElementId);
                
                if (!shapeResult) {
                    // Retirer l'√©l√©ment si le dessin a √©chou√©
                    const index = window.addedElements.findIndex(el => el.id === newElementId);
                    if (index !== -1) {
                        window.addedElements.splice(index, 1);
                    }
                    window.isSelectingShape = false;
                    alert('Erreur: La forme n\'a pas pu √™tre dessin√©e.');
                    return;
                }
                
                // S√©lectionner la forme et activer les interactions (d√©placer, agrandir/r√©duire)
                window.selectedElement = newElement;
                if (typeof selectedElement !== 'undefined') selectedElement = newElement;
                
                // Activer le canvas pour pouvoir d√©placer et redimensionner la forme
                if (currentCanvas) {
                    currentCanvas.style.pointerEvents = 'auto';
                    currentCanvas.style.zIndex = '100';
                }
                
                // R√©initialiser le flag AVANT tout appel diff√©r√© pour √©viter la r√©cursion
                window.isSelectingShape = false;
                
                // Diff√©rer redrawCanvas et updateCanvasPointerEvents pour √©viter "Maximum call stack size exceeded"
                setTimeout(function() {
                    try {
                        if (typeof redrawCanvas === 'function') redrawCanvas();
                        if (typeof updateCanvasPointerEvents === 'function') updateCanvasPointerEvents();
                        console.log('‚úÖ Forme cr√©√©e - vous pouvez la d√©placer (glisser-d√©poser) et l\'agrandir/r√©duire (poign√©es ou molette)');
                    } catch (err) {
                        console.warn('Erreur lors du redessin apr√®s ajout de forme:', err);
                    }
                }, 0);
                
            } catch (error) {
                console.error('ERREUR dans selectShape:', error);
                console.error('Stack trace:', error.stack);
                alert('Erreur: ' + error.message);
                window.isSelectingShape = false;
            }
        });
    };
    
    console.log('selectShape d√©fini globalement:', typeof window.selectShape);
</script>
<div class="page-content">
    <h1 style="color: #2a2a2a; margin-bottom: 15px;">üñºÔ∏è Gestion des Images</h1>
    
    <form class="upload-form" action="/upload" method="POST" enctype="multipart/form-data">
        <input type="file" name="file" accept="image/*" required>
        <button type="submit">üì§ Charger une image</button>
    </form>
    
    {% if image %}
    <div class="media-container" id="imageContainer" style="position: relative;">
        <img id="editableImage" src="{{ url_for('serve_image', filename=image) }}" alt="Image upload√©e">
        <canvas id="editingCanvas"></canvas>
    </div>
    
    <!-- Boutons pour acc√©der au menu Outils et sauvegarder l'image -->
    <div style="margin-top: 10px; text-align: center; position: relative; z-index: 10001 !important; pointer-events: auto !important; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
        <button class="tools-btn" id="toolsBtn" onclick="event.stopPropagation(); event.preventDefault(); if(typeof window.toggleToolsMenu === 'function') { window.toggleToolsMenu(); } else { alert('toggleToolsMenu non trouv√©'); } return false;" style="pointer-events: auto !important; position: relative !important; z-index: 10002 !important; isolation: isolate !important; cursor: pointer !important; background: #6c5ce7 !important; color: white !important; padding: 10px 20px !important; border: none !important; border-radius: 5px !important; font-size: 16px !important; font-weight: bold !important;">üîß Outils</button>
        <button class="tools-btn" id="saveBtn" onclick="event.stopPropagation(); event.preventDefault(); if(typeof window.downloadModifiedImage === 'function') { window.downloadModifiedImage(); } else { alert('downloadModifiedImage non trouv√©'); } return false;" style="pointer-events: auto !important; position: relative !important; z-index: 10002 !important; isolation: isolate !important; cursor: pointer !important; background: #27ae60 !important; color: white !important; padding: 10px 20px !important; border: none !important; border-radius: 5px !important; font-size: 16px !important; font-weight: bold !important;">üíæ Sauvegarder l'image modifi√©e</button>
    </div>
    
    <!-- Menu d√©roulant des outils -->
    <div class="tools-menu" id="toolsMenu" style="position: fixed !important; top: 0 !important; right: -400px !important; width: 350px !important; height: 100vh !important; background: white !important; z-index: 2000 !important; display: none !important; flex-direction: column !important; visibility: hidden !important; opacity: 0 !important; box-shadow: -4px 0 20px rgba(0, 0, 0, 0.3); transition: right 0.4s ease-in-out;">
        <div class="tools-menu-header">
            <h3>Outils d'√©dition</h3>
            <button class="tools-close-btn" onclick="window.toggleToolsMenu();">√ó</button>
        </div>
        <div class="tools-menu-content">
            <button class="tool-btn" onclick="event.stopPropagation(); event.preventDefault(); try { if(typeof window.selectTool === 'function') { window.selectTool('formes'); } else { console.error('selectTool non trouv√©'); alert('Erreur: selectTool non trouv√©. Veuillez recharger la page.'); } } catch(e) { console.error('Erreur lors du clic sur Formes:', e); alert('Erreur: ' + e.message); } return false;" style="pointer-events: auto !important; z-index: 2003 !important; position: relative !important;">üìê Formes</button>
            <button class="tool-btn" onclick="event.stopPropagation(); event.preventDefault(); try { if(typeof window.selectTool === 'function') { window.selectTool('lignes'); } else { console.error('selectTool non trouv√©'); alert('Erreur: selectTool non trouv√©. Veuillez recharger la page.'); } } catch(e) { console.error('Erreur lors du clic sur Lignes:', e); alert('Erreur: ' + e.message); } return false;" style="pointer-events: auto !important; z-index: 2003 !important; position: relative !important;">üìè Lignes</button>
            <button class="tool-btn" onclick="event.stopPropagation(); event.preventDefault(); try { if(typeof window.selectTool === 'function') { window.selectTool('dessin'); } else { console.error('selectTool non trouv√©'); alert('Erreur: selectTool non trouv√©. Veuillez recharger la page.'); } } catch(e) { console.error('Erreur lors du clic sur Dessin:', e); alert('Erreur: ' + e.message); } return false;" style="pointer-events: auto !important; z-index: 2003 !important; position: relative !important;">üñåÔ∏è Dessin</button>
        </div>
    </div>
    
    <!-- Sous-menu des formes -->
    <div class="shapes-submenu" id="shapesSubmenu" style="position: fixed !important; top: 0 !important; right: -400px !important; width: 350px !important; height: 100vh !important; background: white !important; z-index: 2001 !important; display: flex !important; flex-direction: column !important; visibility: visible !important; opacity: 1 !important; box-shadow: -4px 0 20px rgba(0, 0, 0, 0.3) !important;">
        <div class="shapes-submenu-header">
            <button class="shapes-back-btn" onclick="window.closeShapesSubmenu(); return false;" style="pointer-events: auto !important; z-index: 2002 !important; position: relative;">‚Üê Retour</button>
            <h3>Formes disponibles</h3>
        </div>
        <div class="shapes-submenu-content">
            <button class="shape-btn" onclick="if(typeof window.selectShape === 'function') { window.selectShape('square'); } else { alert('selectShape non trouv√©'); } return false;" title="Carr√©">
                <div class="shape-preview square-preview"></div>
                <span>Carr√©</span>
            </button>
            <button class="shape-btn" onclick="if(typeof window.selectShape === 'function') { window.selectShape('rounded-square'); } else { alert('selectShape non trouv√©'); } return false;" title="Carr√© arrondi">
                <div class="shape-preview rounded-square-preview"></div>
                <span>Carr√© arrondi</span>
            </button>
            <button class="shape-btn" onclick="if(typeof window.selectShape === 'function') { window.selectShape('circle'); } else { alert('selectShape non trouv√©'); } return false;" title="Rond">
                <div class="shape-preview circle-preview"></div>
                <span>Rond</span>
            </button>
            <button class="shape-btn" onclick="if(typeof window.selectShape === 'function') { window.selectShape('triangle'); } else { alert('selectShape non trouv√©'); } return false;" title="Triangle isoc√®le">
                <div class="shape-preview triangle-preview"></div>
                <span>Triangle isoc√®le</span>
            </button>
            <button class="shape-btn" onclick="if(typeof window.selectShape === 'function') { window.selectShape('triangle-inverted'); } else { alert('selectShape non trouv√©'); } return false;" title="Triangle isoc√®le invers√©">
                <div class="shape-preview triangle-inverted-preview"></div>
                <span>Triangle isoc√®le invers√©</span>
            </button>
            <button class="shape-btn" onclick="if(typeof window.selectShape === 'function') { window.selectShape('diamond'); } else { alert('selectShape non trouv√©'); } return false;" title="Losange">
                <div class="shape-preview diamond-preview"></div>
                <span>Losange</span>
            </button>
            <button class="shape-btn" onclick="if(typeof window.selectShape === 'function') { window.selectShape('hexagon'); } else { alert('selectShape non trouv√©'); } return false;" title="Hexagone">
                <div class="shape-preview hexagon-preview"></div>
                <span>Hexagone</span>
            </button>
        </div>
    </div>
    
    <!-- Sous-menu des lignes -->
    <div class="shapes-submenu" id="linesSubmenu" style="position: fixed !important; top: 0 !important; right: -400px !important; width: 350px !important; height: 100vh !important; background: white !important; z-index: 2001 !important; display: flex !important; flex-direction: column !important; visibility: visible !important; opacity: 1 !important;">
        <div class="shapes-submenu-header">
            <button class="shapes-back-btn" onclick="window.closeLinesSubmenu(); return false;" style="pointer-events: auto !important; z-index: 2002 !important; position: relative;">‚Üê Retour</button>
            <h3>Types de lignes</h3>
        </div>
        <div class="shapes-submenu-content">
            <button class="shape-btn" onclick="selectLineType('straight-arrow')" title="Fl√®che">
                <div class="line-preview straight-arrow-preview">
                    <svg width="50" height="50" viewBox="0 0 50 50">
                        <line x1="10" y1="25" x2="40" y2="25" stroke="#6c5ce7" stroke-width="2"/>
                        <polygon points="40,25 35,20 35,30" fill="#6c5ce7"/>
                    </svg>
                </div>
                <span>Fl√®che</span>
            </button>
            <button class="shape-btn" onclick="selectLineType('curved')" title="Courbe">
                <div class="line-preview curved-preview">
                    <svg width="50" height="50" viewBox="0 0 50 50">
                        <path d="M 10 40 Q 25 10, 40 40" stroke="#6c5ce7" stroke-width="2" fill="none"/>
                    </svg>
                </div>
                <span>Courbe</span>
            </button>
            <button class="shape-btn" onclick="selectLineType('zigzag')" title="Ligne torsad√©e">
                <div class="line-preview zigzag-preview">
                    <svg width="50" height="50" viewBox="0 0 50 50">
                        <path d="M 10 25 L 20 15 L 30 25 L 40 15" stroke="#6c5ce7" stroke-width="2" fill="none"/>
                    </svg>
                </div>
                <span>Ligne torsad√©e</span>
            </button>
        </div>
    </div>
    
    <!-- Sous-menu du texte -->
    <div class="shapes-submenu" id="textSubmenu" style="position: fixed !important; top: 0 !important; right: -400px !important; width: 350px !important; height: 100vh !important; background: white !important; z-index: 2001 !important; display: flex !important; flex-direction: column !important; visibility: visible !important; opacity: 1 !important; box-shadow: -4px 0 20px rgba(0, 0, 0, 0.3) !important;">
        <div class="shapes-submenu-header">
            <button class="shapes-back-btn" onclick="window.closeTextSubmenu(); return false;" style="pointer-events: auto !important; z-index: 2002 !important; position: relative;">‚Üê Retour</button>
            <h3>Ajouter du texte</h3>
        </div>
        <div class="shapes-submenu-content">
            <div style="width: 100%; padding: 15px;">
                <label style="display: block; margin-bottom: 10px; font-weight: 500;">Texte √† ajouter :</label>
                <input type="text" id="textInput" placeholder="Entrez votre texte ici" 
                       style="width: 100%; padding: 10px; border: 2px solid #e9ecef; border-radius: 5px; font-size: 14px; margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 10px; font-weight: 500;">Taille de police :</label>
                <input type="range" id="fontSizeSlider" min="12" max="72" value="24" 
                       style="width: 100%; margin-bottom: 10px;">
                <span id="fontSizeValue" style="display: block; text-align: center; margin-bottom: 15px;">24px</span>
                <button class="tool-btn" onclick="activateTextMode()" style="width: 100%;">
                    ‚úì Activer le mode texte
                </button>
                <p style="margin-top: 15px; font-size: 12px; color: #666; text-align: center;">
                    Cliquez sur l'image pour placer le texte
                </p>
            </div>
        </div>
    </div>
    
    <!-- Sous-menu du dessin -->
    <div class="shapes-submenu" id="drawSubmenu" style="position: fixed !important; top: 0 !important; right: -400px !important; width: 350px !important; height: 100vh !important; background: white !important; z-index: 2001 !important; display: flex !important; flex-direction: column !important; visibility: visible !important; opacity: 1 !important; box-shadow: -4px 0 20px rgba(0, 0, 0, 0.3) !important;">
        <div class="shapes-submenu-header">
            <button class="shapes-back-btn" onclick="try { if(typeof window.closeDrawSubmenu === 'function') { window.closeDrawSubmenu(); } else { console.error('closeDrawSubmenu non trouv√©'); alert('Erreur: fonction non trouv√©e'); } } catch(e) { console.error('Erreur:', e); alert('Erreur: ' + e.message); } return false;" style="pointer-events: auto !important; z-index: 2002 !important; position: relative !important; cursor: pointer !important;">‚Üê Retour</button>
            <h3>Palette de couleurs</h3>
        </div>
        <div class="shapes-submenu-content">
            <div style="width: 100%; padding: 15px;">
                <label style="display: block; margin-bottom: 10px; font-weight: 500;">Couleur :</label>
                <div class="color-palette" id="colorPalette">
                    <div class="color-item" data-color="#000000" style="background: #000000;" onclick="selectColor('#000000')"></div>
                    <div class="color-item" data-color="#FFFFFF" style="background: #FFFFFF; border: 1px solid #ccc;" onclick="selectColor('#FFFFFF')"></div>
                    <div class="color-item" data-color="#FF0000" style="background: #FF0000;" onclick="selectColor('#FF0000')"></div>
                    <div class="color-item" data-color="#00FF00" style="background: #00FF00;" onclick="selectColor('#00FF00')"></div>
                    <div class="color-item" data-color="#0000FF" style="background: #0000FF;" onclick="selectColor('#0000FF')"></div>
                    <div class="color-item" data-color="#FFFF00" style="background: #FFFF00;" onclick="selectColor('#FFFF00')"></div>
                    <div class="color-item" data-color="#FF00FF" style="background: #FF00FF;" onclick="selectColor('#FF00FF')"></div>
                    <div class="color-item" data-color="#00FFFF" style="background: #00FFFF;" onclick="selectColor('#00FFFF')"></div>
                    <div class="color-item" data-color="#FFD700" style="background: #FFD700;" onclick="selectColor('#FFD700')"></div>
                    <div class="color-item" data-color="#FFA500" style="background: #FFA500;" onclick="selectColor('#FFA500')"></div>
                    <div class="color-item" data-color="#800080" style="background: #800080;" onclick="selectColor('#800080')"></div>
                    <div class="color-item" data-color="#FFC0CB" style="background: #FFC0CB;" onclick="selectColor('#FFC0CB')"></div>
                    <div class="color-item" data-color="#A52A2A" style="background: #A52A2A;" onclick="selectColor('#A52A2A')"></div>
                    <div class="color-item" data-color="#808080" style="background: #808080;" onclick="selectColor('#808080')"></div>
                    <div class="color-item" data-color="#008000" style="background: #008000;" onclick="selectColor('#008000')"></div>
                    <div class="color-item" data-color="#000080" style="background: #000080;" onclick="selectColor('#000080')"></div>
                    <div class="color-item" data-color="#800000" style="background: #800000;" onclick="selectColor('#800000')"></div>
                    <div class="color-item" data-color="#C0C0C0" style="background: #C0C0C0;" onclick="selectColor('#C0C0C0')"></div>
                    <div class="color-item" data-color="#FF6347" style="background: #FF6347;" onclick="selectColor('#FF6347')"></div>
                </div>
                <div style="margin-top: 15px; text-align: center;">
                    <div id="selectedColorDisplay" style="width: 100%; height: 40px; border: 2px solid #6c5ce7; border-radius: 5px; background: #FFD700; margin-bottom: 10px;"></div>
                    <label style="display: block; margin-bottom: 10px; font-weight: 500;">√âpaisseur :</label>
                    <input type="range" id="brushSizeSlider" min="1" max="20" value="5" 
                           style="width: 100%; margin-bottom: 10px;">
                    <span id="brushSizeValue" style="display: block; text-align: center; margin-bottom: 15px;">5px</span>
                    <div style="display: flex; gap: 10px; margin-top: 15px; flex-direction: column;">
                        <button class="tool-btn" onclick="activateMarkerMode()" style="flex: 1; background: #6c5ce7; width: 100%;">
                            üñçÔ∏è Feutre
                        </button>
                        <button class="tool-btn" onclick="activateEraserMode()" style="flex: 1; background: #e74c3c; width: 100%; margin-top: 10px;">
                            üßπ Gomme
                        </button>
                        <button class="tool-btn" onclick="deactivateDrawingTools()" style="flex: 1; background: #95a5a6; width: 100%; margin-top: 10px;">
                            ‚úã D√©sactiver
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Overlay pour fermer le menu en cliquant √† l'ext√©rieur -->
    <div class="tools-overlay" id="toolsOverlay" onclick="window.toggleToolsMenu();"></div>
    
    <!-- Menu contextuel pour supprimer les √©l√©ments -->
    <div class="context-menu" id="contextMenu">
        <button class="context-menu-item" onclick="deleteSelectedElement()">
            üóëÔ∏è Supprimer
        </button>
    </div>
    
    {% if processed_image %}
    <div class="info-section" style="margin-top: 15px;">
        <h4>‚úÖ Image trait√©e disponible :</h4>
        <div class="media-container">
            <img src="{{ url_for('serve_image', filename=processed_image) }}" alt="Image trait√©e">
        </div>
        <div style="text-align: center; margin-top: 15px;">
            <a href="{{ url_for('serve_image', filename=processed_image) }}" download style="color: #4a90e2; text-decoration: none; font-weight: 500;">
                üì• T√©l√©charger l'image trait√©e
            </a>
        </div>
    </div>
    {% endif %}
    {% endif %}
</div>

<script>
// V√©rifier que toutes les fonctions globales sont disponibles
document.addEventListener('DOMContentLoaded', function() {
    console.log('=== V√©rification des fonctions globales ===');
    console.log('window.toggleToolsMenu:', typeof window.toggleToolsMenu);
    console.log('window.selectTool:', typeof window.selectTool);
    console.log('window.selectShape:', typeof window.selectShape);
    console.log('window.closeShapesSubmenu:', typeof window.closeShapesSubmenu);
    console.log('window.closeLinesSubmenu:', typeof window.closeLinesSubmenu);
    console.log('window.closeDrawSubmenu:', typeof window.closeDrawSubmenu);
    
    // Si selectTool n'est pas disponible, essayer de la red√©finir
    if (typeof window.selectTool !== 'function') {
        console.error('ERREUR CRITIQUE: window.selectTool n\'est pas disponible!');
        alert('Erreur: Les fonctions JavaScript ne sont pas charg√©es. Veuillez recharger la page.');
    }
});

function deleteFile(filename) {
    if (confirm('√ätes-vous s√ªr de vouloir supprimer cette image ?')) {
        fetch("/delete/" + filename, {
            method: "POST"
        })
        .then(() => {
            location.reload();
        });
    }
}

// La fonction toggleToolsMenu est d√©j√† d√©finie en haut du script dans window.toggleToolsMenu
// Pas besoin de la red√©finir ici

let currentTool = null;
let currentShape = null;
let currentLineType = null;
let isDrawing = false;
let isTextMode = false;
let isDrawMode = false;
let isMarkerMode = false;
let isEraserMode = false;
let isMoving = false;
let isResizing = false;
let selectedElement = null;
// Rendre selectedElement accessible globalement
window.selectedElement = selectedElement;
let resizeHandle = null;
let currentText = '';
let currentFontSize = 24;
let currentDrawColor = '#FFD700';
let currentBrushSize = 5;
let startX = 0;
let startY = 0;
let lastX = 0;
let lastY = 0;
let offsetX = 0;
let offsetY = 0;
let initialElementState = null;
let initialLineMoveState = null;
let canvas, ctx, img, imageData;
let addedElements = []; // Stocker tous les √©l√©ments ajout√©s (formes et textes)
let eventsSetup = false; // Flag pour √©viter les doublons d'√©v√©nements

// Flags pour √©viter les r√©cursions infinies
let isRedrawing = false;
let isUpdatingPointerEvents = false;
let isResizingCanvas = false;
let isInitializingCanvas = false;

// Rendre addedElements accessible globalement
// Initialiser window.addedElements si ce n'est pas d√©j√† fait
if (!window.addedElements) {
    window.addedElements = [];
}
// Synchroniser avec la variable locale
addedElements = window.addedElements;

function initCanvas() {
    // √âviter les appels r√©cursifs
    if (isInitializingCanvas) {
        console.warn('initCanvas d√©j√† en cours, appel ignor√©');
        return;
    }
    
    isInitializingCanvas = true;
    
    try {
        const imageElement = document.getElementById('editableImage');
        if (!imageElement) {
            console.log('Image non trouv√©e');
            isInitializingCanvas = false;
            return;
        }
        
        canvas = document.getElementById('editingCanvas');
        if (!canvas) {
            console.log('Canvas non trouv√©');
            isInitializingCanvas = false;
            return;
        }
        
        // Rendre canvas accessible globalement
        window.canvas = canvas;
        
        ctx = canvas.getContext('2d');
        if (!ctx) {
            console.log('Contexte canvas non disponible');
            isInitializingCanvas = false;
            return;
        }
        
        // Rendre ctx accessible globalement
        window.ctx = ctx;
        
        img = imageElement;
        
        // Forcer la visibilit√© du canvas (sans d√©clencher d'√©v√©nements)
        if (canvas.style.display !== 'block') {
            canvas.style.setProperty('display', 'block', 'important');
        }
        if (canvas.style.visibility !== 'visible') {
            canvas.style.setProperty('visibility', 'visible', 'important');
        }
        if (canvas.style.opacity !== '1') {
            canvas.style.setProperty('opacity', '1', 'important');
        }
        // Position/taille du canvas sont d√©finies par resizeCanvas() pour recouvrir l'image (d√©file avec la page)
        
        // Attendre que l'image soit charg√©e puis positionner le canvas sur l'image
        if (img.complete && img.naturalWidth > 0) {
            if (!isResizingCanvas) resizeCanvas();
        } else {
            img.onload = function() {
                if (!isResizingCanvas) resizeCanvas();
            };
            img.onerror = function() {
                console.error('Erreur lors du chargement de l\'image');
            };
        }
        // R√©aligner le canvas si la taille de l'image change (layout, zoom, etc.)
        if (typeof ResizeObserver !== 'undefined') {
            try {
                const ro = new ResizeObserver(function() {
                    if (!isResizingCanvas && canvas && img) resizeCanvas();
                });
                ro.observe(img);
            } catch (err) { /* ignore */ }
        }
    } catch (error) {
        console.error('Erreur lors de l\'initialisation du canvas:', error);
    } finally {
        isInitializingCanvas = false;
    }
}

// Impl√©mentation r√©elle (appel√©e de fa√ßon diff√©r√©e pour √©viter r√©cursion / stack overflow)
function updateCanvasPointerEventsImpl() {
    if (!canvas) return;
    
    if (isUpdatingPointerEvents) return;
    isUpdatingPointerEvents = true;
    
    try {
        const menu = document.getElementById('toolsMenu');
        const isMenuOpen = menu && menu.classList.contains('active');
        
        const toolsBtn = document.getElementById('toolsBtn');
        const saveBtn = document.getElementById('saveBtn');
        let isOverButton = false;
        if ((toolsBtn || saveBtn) && window.mouseX !== undefined && window.mouseY !== undefined) {
            const element = document.elementFromPoint(window.mouseX, window.mouseY);
            isOverButton = element && (
                (toolsBtn && (element === toolsBtn || element.closest('#toolsBtn'))) ||
                (saveBtn && (element === saveBtn || element.closest('#saveBtn'))) ||
                element.closest('.tools-btn')
            );
        }
        
        if (isMenuOpen || isOverButton) {
            if (canvas.style.pointerEvents !== 'none') {
                canvas.style.pointerEvents = 'none';
                canvas.style.zIndex = '50';
            }
            return;
        }
        
        const currentSelected = window.selectedElement || selectedElement;
        const hasActiveTool = currentShape !== null || 
                             currentLineType !== null || 
                             isTextMode || 
                             isDrawMode || 
                             isMarkerMode ||
                             isEraserMode ||
                             currentSelected !== null ||
                             (window.addedElements && window.addedElements.length > 0);
        
        if (hasActiveTool) {
            if (canvas.style.pointerEvents !== 'auto') {
                canvas.style.pointerEvents = 'auto';
                canvas.style.zIndex = '1000';
            }
        } else {
            if (canvas.style.pointerEvents !== 'none') {
                canvas.style.pointerEvents = 'none';
                canvas.style.zIndex = '50';
            }
        }
    } finally {
        isUpdatingPointerEvents = false;
    }
}

// Toujours diff√©rer pour ne jamais ex√©cuter dans la pile d'un event handler (√©vite "Maximum call stack size exceeded")
let updateCanvasPointerEventsScheduled = false;
function updateCanvasPointerEvents() {
    if (updateCanvasPointerEventsScheduled) return;
    updateCanvasPointerEventsScheduled = true;
    setTimeout(function() {
        updateCanvasPointerEventsScheduled = false;
        updateCanvasPointerEventsImpl();
    }, 0);
}

// Tracker la position de la souris pour updateCanvasPointerEvents
// Ajouter un throttling pour √©viter les appels trop fr√©quents
let lastUpdateTime = 0;
const UPDATE_THROTTLE = 50; // Mettre √† jour au maximum toutes les 50ms

document.addEventListener('mousemove', function(e) {
    window.mouseX = e.clientX;
    window.mouseY = e.clientY;
    // Mettre √† jour le canvas en temps r√©el avec throttling
    const now = Date.now();
    if (canvas && (now - lastUpdateTime > UPDATE_THROTTLE)) {
        lastUpdateTime = now;
        updateCanvasPointerEvents();
    }
}, true);

function resizeCanvas() {
    if (!canvas || !img) return;
    
    if (isResizingCanvas) return;
    isResizingCanvas = true;
    
    setTimeout(() => {
        try {
            const imageElement = document.getElementById('editableImage');
            if (!imageElement || imageElement.offsetWidth === 0 || imageElement.offsetHeight === 0) {
                isResizingCanvas = false;
                return;
            }
            // Positionner le canvas exactement sur l'image pour qu'il d√©file avec la page
            const w = imageElement.offsetWidth;
            const h = imageElement.offsetHeight;
            const left = imageElement.offsetLeft;
            const top = imageElement.offsetTop;
            
            canvas.width = w;
            canvas.height = h;
            canvas.style.position = 'absolute';
            canvas.style.left = left + 'px';
            canvas.style.top = top + 'px';
            canvas.style.width = w + 'px';
            canvas.style.height = h + 'px';
            canvas.style.pointerEvents = 'none';
            canvas.style.cursor = 'default';
            canvas.style.zIndex = '10';
            canvas.style.clipPath = 'none';
            canvas.style.webkitClipPath = 'none';
            
            updateCanvasPointerEvents();
            if (window.addedElements && window.addedElements.length > 0 && !isRedrawing) {
                redrawCanvas();
            }
        } catch (error) {
            console.error('Erreur lors du redimensionnement du canvas:', error);
        } finally {
            isResizingCanvas = false;
        }
    }, 50);
}

// La fonction selectTool est d√©j√† d√©finie en haut du script dans window.selectTool
// Pas besoin de la red√©finir ici

function showShapesSubmenu() {
    const shapesMenu = document.getElementById('shapesSubmenu');
    if (shapesMenu) {
        shapesMenu.classList.add('active');
        // Forcer les styles pour s'assurer que le menu est visible
        shapesMenu.style.right = '0';
        shapesMenu.style.display = 'flex';
        shapesMenu.style.visibility = 'visible';
        shapesMenu.style.opacity = '1';
        shapesMenu.style.zIndex = '2001';
        console.log('Sous-menu Formes ouvert');
        // S'assurer que le canvas est d√©sactiv√©
        if (canvas) {
            canvas.style.pointerEvents = 'none';
            canvas.style.zIndex = '50';
        }
    } else {
        console.error('Sous-menu Formes non trouv√©');
    }
}

// La fonction closeShapesSubmenu est d√©j√† d√©finie en haut du script

function showLinesSubmenu() {
    const linesMenu = document.getElementById('linesSubmenu');
    if (linesMenu) {
        linesMenu.classList.add('active');
        // Forcer les styles pour s'assurer que le menu est visible
        linesMenu.style.right = '0';
        linesMenu.style.display = 'flex';
        linesMenu.style.visibility = 'visible';
        linesMenu.style.opacity = '1';
        linesMenu.style.zIndex = '2001';
        console.log('Sous-menu Lignes ouvert');
        // S'assurer que le canvas est d√©sactiv√©
        if (canvas) {
            canvas.style.pointerEvents = 'none';
            canvas.style.zIndex = '50';
        }
    } else {
        console.error('Sous-menu Lignes non trouv√©');
    }
}

// La fonction closeLinesSubmenu est d√©j√† d√©finie en haut du script

// Ajouter une ligne √† l'image au centre (comme les formes) - d√©pla√ßable et rallongable
window.selectLine = function(lineType) {
    console.log('=== selectLine appel√© avec:', lineType);
    try {
        if (typeof window.closeLinesSubmenu === 'function') {
            window.closeLinesSubmenu();
        }
        currentLineType = null;
        currentShape = null;
        isTextMode = false;
        isDrawMode = false;
        
        const currentCanvas = document.getElementById('editingCanvas');
        const imageElement = document.getElementById('editableImage');
        if (!currentCanvas || !imageElement) {
            alert('Canvas ou image non trouv√©.');
            return;
        }
        if (!imageElement.complete || imageElement.naturalWidth === 0) {
            alert('Veuillez attendre que l\'image soit charg√©e.');
            return;
        }
        // Coordonn√©es en espace canvas pour que la ligne d√©file avec l'image
        const cw = currentCanvas.width || imageElement.offsetWidth;
        const ch = currentCanvas.height || imageElement.offsetHeight;
        const centerX = cw / 2;
        const centerY = ch / 2;
        const defaultLength = 80;
        const x1 = centerX - defaultLength;
        const y1 = centerY;
        const x2 = centerX + defaultLength;
        const y2 = centerY;
        
        if (!window.addedElements) window.addedElements = [];
        const newElementId = 'line_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        const newElement = {
            type: 'line',
            id: newElementId,
            lineType: lineType,
            x1: x1, y1: y1, x2: x2, y2: y2
        };
        window.addedElements.push(newElement);
        
        window.selectedElement = newElement;
        selectedElement = newElement;
        
        if (canvas && ctx) {
            canvas.style.pointerEvents = 'auto';
            canvas.style.zIndex = '100';
        }
        redrawCanvas();
        updateCanvasPointerEvents();
        console.log('‚úÖ Ligne ajout√©e:', newElement);
    } catch (error) {
        console.error('Erreur selectLine:', error);
        alert('Erreur: ' + error.message);
    }
};

function selectLineType(lineType) {
    // Comportement par d√©faut : ajouter la ligne √† l'image imm√©diatement
    if (typeof window.selectLine === 'function') {
        window.selectLine(lineType);
    } else {
        currentLineType = lineType;
        currentShape = null;
        isTextMode = false;
        isDrawMode = false;
        closeLinesSubmenu();
        if (canvas && ctx) canvas.style.cursor = 'crosshair';
        updateCanvasPointerEvents();
    }
}

function showTextSubmenu() {
    const textMenu = document.getElementById('textSubmenu');
    if (textMenu) {
        textMenu.classList.add('active');
        // Forcer les styles pour s'assurer que le menu est visible
        textMenu.style.right = '0';
        textMenu.style.display = 'flex';
        textMenu.style.visibility = 'visible';
        textMenu.style.opacity = '1';
        textMenu.style.zIndex = '2001';
        console.log('Sous-menu Texte ouvert');
        // S'assurer que le canvas est d√©sactiv√©
        if (canvas) {
            canvas.style.pointerEvents = 'none';
            canvas.style.zIndex = '50';
        }
    } else {
        console.error('Sous-menu Texte non trouv√©');
    }
}

// La fonction closeTextSubmenu est d√©j√† d√©finie en haut du script

function activateTextMode() {
    currentText = document.getElementById('textInput').value;
    currentFontSize = parseInt(document.getElementById('fontSizeSlider').value);
    isTextMode = true;
    isDrawMode = false;
    isMarkerMode = false;
    currentShape = null;
    currentLineType = null;
    selectedElement = null;
    closeTextSubmenu();
    
    if (canvas && ctx) {
        canvas.style.cursor = 'text';
    }
    
    if (!currentText) {
        alert('Veuillez entrer un texte');
        isTextMode = false;
        updateCanvasPointerEvents();
        return;
    }
    
    // Activer le canvas pour le texte
    updateCanvasPointerEvents();
}

function showDrawSubmenu() {
    const drawMenu = document.getElementById('drawSubmenu');
    if (drawMenu) {
        drawMenu.classList.add('active');
        // Forcer les styles pour s'assurer que le menu est visible
        drawMenu.style.right = '0';
        drawMenu.style.display = 'flex';
        drawMenu.style.visibility = 'visible';
        drawMenu.style.opacity = '1';
        drawMenu.style.zIndex = '2001';
        console.log('Sous-menu Dessin ouvert');
        // S'assurer que le canvas est d√©sactiv√©
        if (canvas) {
            canvas.style.pointerEvents = 'none';
            canvas.style.zIndex = '50';
        }
    } else {
        console.error('Sous-menu Dessin non trouv√©');
    }
}

// La fonction closeDrawSubmenu est d√©j√† d√©finie en haut du script dans window.closeDrawSubmenu
// Pas besoin de la red√©finir ici

function selectColor(color) {
    currentDrawColor = color;
    document.getElementById('selectedColorDisplay').style.background = color;
    
    // Mettre √† jour la s√©lection visuelle
    document.querySelectorAll('.color-item').forEach(item => {
        item.classList.remove('selected');
        if (item.getAttribute('data-color') === color) {
            item.classList.add('selected');
        }
    });
}

function activateDrawMode() {
    isDrawMode = true;
    isMarkerMode = false;
    isTextMode = false;
    currentShape = null;
    currentLineType = null;
    currentBrushSize = parseInt(document.getElementById('brushSizeSlider').value);
    if (typeof window.closeDrawSubmenu === 'function') {
        window.closeDrawSubmenu();
    }
    
    if (canvas && ctx) {
        canvas.style.cursor = 'crosshair';
    }
    
    // Activer le canvas pour le dessin
    updateCanvasPointerEvents();
}

function activateMarkerMode() {
    isMarkerMode = true;
    isEraserMode = false;
    isDrawMode = false;
    isTextMode = false;
    currentShape = null;
    currentLineType = null;
    currentBrushSize = parseInt(document.getElementById('brushSizeSlider').value);
    if (typeof window.closeDrawSubmenu === 'function') {
        window.closeDrawSubmenu();
    }
    
    if (canvas && ctx) {
        canvas.style.cursor = 'crosshair';
    }
    
    // Activer le canvas pour le feutre
    updateCanvasPointerEvents();
}

function activateEraserMode() {
    isEraserMode = true;
    isMarkerMode = false;
    isDrawMode = false;
    isTextMode = false;
    currentShape = null;
    currentLineType = null;
    currentBrushSize = parseInt(document.getElementById('brushSizeSlider').value);
    if (typeof window.closeDrawSubmenu === 'function') {
        window.closeDrawSubmenu();
    }
    
    if (canvas && ctx) {
        canvas.style.cursor = 'grab';
    }
    
    // Activer le canvas pour la gomme
    updateCanvasPointerEvents();
}

function deactivateDrawingTools() {
    isMarkerMode = false;
    isEraserMode = false;
    isDrawMode = false;
    isTextMode = false;
    currentShape = null;
    currentLineType = null;
    
    if (canvas && ctx) {
        canvas.style.cursor = 'default';
    }
    
    // D√©sactiver le canvas si aucun √©l√©ment n'est s√©lectionn√©
    const hasSelectedElement = window.selectedElement || (window.addedElements && window.addedElements.length > 0);
    if (!hasSelectedElement && canvas) {
        canvas.style.pointerEvents = 'none';
        canvas.style.zIndex = '50';
    } else {
        updateCanvasPointerEvents();
    }
}

// Fonction pour exporter l'image modifi√©e - retourne une promesse avec le blob
window.exportImageToBlob = function() {
    return new Promise((resolve, reject) => {
        try {
            const imageElement = document.getElementById('editableImage');
            const editingCanvas = document.getElementById('editingCanvas');
            
            if (!imageElement || !editingCanvas) {
                reject(new Error('Image ou canvas non trouv√©.'));
                return;
            }
            
            if (!imageElement.complete || imageElement.naturalWidth === 0) {
                reject(new Error('Veuillez attendre que l\'image soit compl√®tement charg√©e.'));
                return;
            }
            
            const exportCanvas = document.createElement('canvas');
            const exportCtx = exportCanvas.getContext('2d');
            
            exportCanvas.width = imageElement.naturalWidth;
            exportCanvas.height = imageElement.naturalHeight;
            
            exportCtx.drawImage(imageElement, 0, 0, exportCanvas.width, exportCanvas.height);
            
            const scaleX = exportCanvas.width / editingCanvas.width;
            const scaleY = exportCanvas.height / editingCanvas.height;
            
            exportCtx.drawImage(editingCanvas, 0, 0, editingCanvas.width, editingCanvas.height, 
                               0, 0, exportCanvas.width, exportCanvas.height);
            
            const elements = window.addedElements || [];
            elements.forEach(element => {
                if (element.type === 'shape') {
                    exportCtx.save();
                    const scaledX = element.x * scaleX;
                    const scaledY = element.y * scaleY;
                    const scaledWidth = element.width * scaleX;
                    const scaledHeight = element.height * scaleY;
                    
                    const shapeType = element.shapeType;
                    exportCtx.strokeStyle = '#FFD700';
                    exportCtx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                    exportCtx.lineWidth = 3;
                    
                    switch(shapeType) {
                        case 'square':
                            exportCtx.fillRect(scaledX, scaledY, scaledWidth, scaledHeight);
                            exportCtx.strokeRect(scaledX, scaledY, scaledWidth, scaledHeight);
                            break;
                        case 'rounded-square':
                            const radius = Math.min(scaledWidth, scaledHeight) * 0.2;
                            exportCtx.beginPath();
                            exportCtx.moveTo(scaledX + radius, scaledY);
                            exportCtx.lineTo(scaledX + scaledWidth - radius, scaledY);
                            exportCtx.quadraticCurveTo(scaledX + scaledWidth, scaledY, scaledX + scaledWidth, scaledY + radius);
                            exportCtx.lineTo(scaledX + scaledWidth, scaledY + scaledHeight - radius);
                            exportCtx.quadraticCurveTo(scaledX + scaledWidth, scaledY + scaledHeight, scaledX + scaledWidth - radius, scaledY + scaledHeight);
                            exportCtx.lineTo(scaledX + radius, scaledY + scaledHeight);
                            exportCtx.quadraticCurveTo(scaledX, scaledY + scaledHeight, scaledX, scaledY + scaledHeight - radius);
                            exportCtx.lineTo(scaledX, scaledY + radius);
                            exportCtx.quadraticCurveTo(scaledX, scaledY, scaledX + radius, scaledY);
                            exportCtx.closePath();
                            exportCtx.fill();
                            exportCtx.stroke();
                            break;
                        case 'circle':
                            const centerX = scaledX + scaledWidth / 2;
                            const centerY = scaledY + scaledHeight / 2;
                            const radius_circle = Math.min(scaledWidth, scaledHeight) / 2;
                            exportCtx.beginPath();
                            exportCtx.arc(centerX, centerY, radius_circle, 0, 2 * Math.PI);
                            exportCtx.fill();
                            exportCtx.stroke();
                            break;
                        case 'triangle':
                            exportCtx.beginPath();
                            exportCtx.moveTo(scaledX + scaledWidth / 2, scaledY);
                            exportCtx.lineTo(scaledX, scaledY + scaledHeight);
                            exportCtx.lineTo(scaledX + scaledWidth, scaledY + scaledHeight);
                            exportCtx.closePath();
                            exportCtx.fill();
                            exportCtx.stroke();
                            break;
                        case 'triangle-inverted':
                            exportCtx.beginPath();
                            exportCtx.moveTo(scaledX + scaledWidth / 2, scaledY + scaledHeight);
                            exportCtx.lineTo(scaledX, scaledY);
                            exportCtx.lineTo(scaledX + scaledWidth, scaledY);
                            exportCtx.closePath();
                            exportCtx.fill();
                            exportCtx.stroke();
                            break;
                        case 'diamond':
                            exportCtx.beginPath();
                            exportCtx.moveTo(scaledX + scaledWidth / 2, scaledY);
                            exportCtx.lineTo(scaledX + scaledWidth, scaledY + scaledHeight / 2);
                            exportCtx.lineTo(scaledX + scaledWidth / 2, scaledY + scaledHeight);
                            exportCtx.lineTo(scaledX, scaledY + scaledHeight / 2);
                            exportCtx.closePath();
                            exportCtx.fill();
                            exportCtx.stroke();
                            break;
                        case 'hexagon':
                            const centerX_hex = scaledX + scaledWidth / 2;
                            const centerY_hex = scaledY + scaledHeight / 2;
                            const radius_hex = Math.min(scaledWidth, scaledHeight) / 2;
                            exportCtx.beginPath();
                            for (let i = 0; i < 6; i++) {
                                const angle = (Math.PI / 3) * i;
                                const px = centerX_hex + radius_hex * Math.cos(angle);
                                const py = centerY_hex + radius_hex * Math.sin(angle);
                                if (i === 0) {
                                    exportCtx.moveTo(px, py);
                                } else {
                                    exportCtx.lineTo(px, py);
                                }
                            }
                            exportCtx.closePath();
                            exportCtx.fill();
                            exportCtx.stroke();
                            break;
                    }
                    exportCtx.restore();
                } else if (element.type === 'text') {
                    exportCtx.save();
                    const scaledX = element.x * scaleX;
                    const scaledY = element.y * scaleY;
                    const scaledFontSize = (element.fontSize || 24) * scaleX;
                    exportCtx.fillStyle = '#FFD700';
                    exportCtx.strokeStyle = '#000000';
                    exportCtx.lineWidth = 2 * scaleX;
                    exportCtx.font = `bold ${scaledFontSize}px Arial`;
                    exportCtx.textAlign = 'left';
                    exportCtx.textBaseline = 'top';
                    exportCtx.strokeText(element.text, scaledX, scaledY);
                    exportCtx.fillText(element.text, scaledX, scaledY);
                    exportCtx.restore();
                } else if (element.type === 'line') {
                    const x1 = element.x1 * scaleX, y1 = element.y1 * scaleY, x2 = element.x2 * scaleX, y2 = element.y2 * scaleY;
                    exportCtx.save();
                    exportCtx.strokeStyle = '#FFD700';
                    exportCtx.fillStyle = '#FFD700';
                    exportCtx.lineWidth = 3 * scaleX;
                    exportCtx.lineCap = 'round';
                    exportCtx.lineJoin = 'round';
                    if (element.lineType === 'straight-arrow') {
                        exportCtx.beginPath();
                        exportCtx.moveTo(x1, y1);
                        exportCtx.lineTo(x2, y2);
                        exportCtx.stroke();
                        const angle = Math.atan2(y2 - y1, x2 - x1);
                        const arrowLength = 15 * scaleX;
                        exportCtx.beginPath();
                        exportCtx.moveTo(x2, y2);
                        exportCtx.lineTo(x2 - arrowLength * Math.cos(angle - Math.PI / 6), y2 - arrowLength * Math.sin(angle - Math.PI / 6));
                        exportCtx.lineTo(x2 - arrowLength * Math.cos(angle + Math.PI / 6), y2 - arrowLength * Math.sin(angle + Math.PI / 6));
                        exportCtx.closePath();
                        exportCtx.fill();
                    } else if (element.lineType === 'curved') {
                        const midX = (x1 + x2) / 2, midY = (y1 + y2) / 2;
                        const controlX = midX + (y2 - y1) * 0.3, controlY = midY - (x2 - x1) * 0.3;
                        exportCtx.beginPath();
                        exportCtx.moveTo(x1, y1);
                        exportCtx.quadraticCurveTo(controlX, controlY, x2, y2);
                        exportCtx.stroke();
                    } else if (element.lineType === 'zigzag') {
                        const dx = x2 - x1, dy = y2 - y1;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const segments = Math.max(3, Math.floor(distance / (20 * scaleX)));
                        const perpX = -dy / distance, perpY = dx / distance;
                        const amplitude = 10 * scaleX;
                        exportCtx.beginPath();
                        exportCtx.moveTo(x1, y1);
                        for (let i = 1; i <= segments; i++) {
                            const t = i / segments;
                            const x = x1 + dx * t, y = y1 + dy * t;
                            const offset = (i % 2 === 0 ? 1 : -1) * amplitude;
                            exportCtx.lineTo(x + perpX * offset, y + perpY * offset);
                        }
                        exportCtx.stroke();
                    }
                    exportCtx.restore();
                }
            });
            
            exportCanvas.toBlob(function(blob) {
                if (!blob) {
                    reject(new Error('Erreur lors de la cr√©ation de l\'image.'));
                    return;
                }
                resolve(blob);
            }, 'image/png');
            
        } catch (error) {
            reject(error);
        }
    });
};

// Fonction pour exporter/envoyer l'image modifi√©e (version originale pour compatibilit√©)
window.exportImage = function() {
    window.exportImageToBlob()
        .then(blob => {
            const formData = new FormData();
            formData.append('file', blob, 'image_modifiee.png');
            
            return fetch('/upload', {
                method: 'POST',
                body: formData
            });
        })
        .then(response => {
            if (response.ok) {
                return response.text();
            } else {
                throw new Error('Erreur lors de l\'envoi de l\'image.');
            }
        })
        .then(() => {
            alert('Image modifi√©e envoy√©e avec succ√®s !');
            window.location.reload();
        })
        .catch(error => {
            console.error('Erreur:', error);
            alert('Erreur lors de l\'envoi: ' + error.message);
        });
};

// Fonction pour t√©l√©charger l'image modifi√©e sur l'ordinateur/t√©l√©phone
window.downloadModifiedImage = function() {
    const saveBtn = document.getElementById('saveBtn');
    if (saveBtn) {
        saveBtn.disabled = true;
        saveBtn.style.opacity = '0.6';
        saveBtn.textContent = '‚è≥ Pr√©paration...';
    }
    
    window.exportImageToBlob()
        .then(blob => {
            // Cr√©er un lien de t√©l√©chargement
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            
            // G√©n√©rer un nom de fichier avec la date et l'heure
            const now = new Date();
            const dateStr = now.toISOString().slice(0, 19).replace(/:/g, '-').replace('T', '_');
            link.download = `image_modifiee_${dateStr}.png`;
            
            // Ajouter le lien au DOM, cliquer dessus, puis le retirer
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Nettoyer l'URL apr√®s un court d√©lai
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 100);
            
            // Restaurer le bouton
            if (saveBtn) {
                saveBtn.disabled = false;
                saveBtn.style.opacity = '1';
                saveBtn.textContent = 'üíæ Sauvegarder l\'image modifi√©e';
            }
            
            // Afficher un message de confirmation
            alert('Image modifi√©e t√©l√©charg√©e avec succ√®s !');
        })
        .catch(error => {
            console.error('Erreur:', error);
            alert('Erreur lors du t√©l√©chargement: ' + error.message);
            
            // Restaurer le bouton en cas d'erreur
            if (saveBtn) {
                saveBtn.disabled = false;
                saveBtn.style.opacity = '1';
                saveBtn.textContent = 'üíæ Sauvegarder l\'image modifi√©e';
            }
        });
};

// Gestion des sliders
document.addEventListener('DOMContentLoaded', function() {
    const fontSizeSlider = document.getElementById('fontSizeSlider');
    const fontSizeValue = document.getElementById('fontSizeValue');
    if (fontSizeSlider && fontSizeValue) {
        fontSizeSlider.addEventListener('input', function() {
            fontSizeValue.textContent = this.value + 'px';
        });
    }
    
    const brushSizeSlider = document.getElementById('brushSizeSlider');
    const brushSizeValue = document.getElementById('brushSizeValue');
    if (brushSizeSlider && brushSizeValue) {
        brushSizeSlider.addEventListener('input', function() {
            brushSizeValue.textContent = this.value + 'px';
            if (isDrawMode) {
                currentBrushSize = parseInt(this.value);
            }
        });
    }
    
    // Initialiser la couleur s√©lectionn√©e
    selectColor('#FFD700');
});

// La fonction selectShape est maintenant d√©finie globalement en haut du script (window.selectShape)
// La fonction drawShape est maintenant d√©finie globalement en haut du script (window.drawShape)

// Garder aussi la fonction locale pour compatibilit√©
function drawShape(shapeType, x, y, width, height, elementId = null) {
    if (typeof window.drawShape === 'function') {
        return window.drawShape(shapeType, x, y, width, height, elementId);
    } else {
        console.error('window.drawShape n\'est pas d√©finie');
        return null;
    }
}

function drawLine(lineType, x1, y1, x2, y2) {
    if (!ctx) return;
    
    ctx.strokeStyle = '#FFD700';
    ctx.fillStyle = '#FFD700';
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    switch(lineType) {
        case 'straight-arrow':
            // Dessiner la ligne droite
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            
            // Dessiner la fl√®che
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const arrowLength = 15;
            const arrowWidth = 8;
            
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(
                x2 - arrowLength * Math.cos(angle - Math.PI / 6),
                y2 - arrowLength * Math.sin(angle - Math.PI / 6)
            );
            ctx.lineTo(
                x2 - arrowLength * Math.cos(angle + Math.PI / 6),
                y2 - arrowLength * Math.sin(angle + Math.PI / 6)
            );
            ctx.closePath();
            ctx.fill();
            break;
            
        case 'curved':
            // Ligne courbe (courbe de B√©zier quadratique)
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;
            const controlX = midX + (y2 - y1) * 0.3;
            const controlY = midY - (x2 - x1) * 0.3;
            
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.quadraticCurveTo(controlX, controlY, x2, y2);
            ctx.stroke();
            break;
            
        case 'zigzag':
            // Ligne torsad√©e (zigzag)
            const dx = x2 - x1;
            const dy = y2 - y1;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const segments = Math.max(3, Math.floor(distance / 20));
            const segmentLength = distance / segments;
            const perpX = -dy / distance;
            const perpY = dx / distance;
            const amplitude = 10;
            
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            
            for (let i = 1; i <= segments; i++) {
                const t = i / segments;
                const x = x1 + dx * t;
                const y = y1 + dy * t;
                const offset = (i % 2 === 0 ? 1 : -1) * amplitude;
                
                ctx.lineTo(
                    x + perpX * offset,
                    y + perpY * offset
                );
            }
            
            ctx.stroke();
            break;
    }
}

function drawTextOnCanvas(text, x, y, elementId = null) {
    if (!ctx) return;
    
    const id = elementId || 'text_' + Date.now();
    const fontSize = currentFontSize;
    
    ctx.fillStyle = '#FFD700';
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 2;
    ctx.font = `bold ${fontSize}px Arial`;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    
    // Mesurer le texte pour la zone de s√©lection
    const metrics = ctx.measureText(text);
    const textWidth = metrics.width;
    const textHeight = fontSize;
    
    // Dessiner le texte avec contour
    ctx.strokeText(text, x, y);
    ctx.fillText(text, x, y);
    
    // Si c'est un nouvel √©l√©ment, l'ajouter √† la liste
    if (!elementId) {
        if (!window.addedElements) {
            window.addedElements = [];
        }
        window.addedElements.push({
            type: 'text',
            id: id,
            text: text,
            x: x,
            y: y,
            fontSize: fontSize
        });
    }
    
    return { id, x, y, width: textWidth, height: textHeight };
}

// Impl√©mentation r√©elle du redessin (appel√©e de fa√ßon diff√©r√©e pour √©viter stack overflow)
function redrawCanvasImpl() {
    if (isRedrawing) return;
    isRedrawing = true;
    
    try {
        let currentCtx = window.ctx || ctx;
        let currentCanvas = window.canvas || canvas;
        
        if (!currentCanvas) {
            currentCanvas = document.getElementById('editingCanvas');
            if (currentCanvas) window.canvas = currentCanvas;
        }
        if (!currentCtx && currentCanvas) {
            currentCtx = currentCanvas.getContext('2d');
            if (currentCtx) window.ctx = currentCtx;
        }
        
        if (!currentCtx || !currentCanvas) {
            isRedrawing = false;
            return;
        }
        
        if (currentCanvas.width === 0 || currentCanvas.height === 0) {
            currentCanvas.width = window.innerWidth || 1920;
            currentCanvas.height = window.innerHeight || 1080;
        }
        
        if (currentCanvas.style.display !== 'block') currentCanvas.style.setProperty('display', 'block', 'important');
        if (currentCanvas.style.visibility !== 'visible') currentCanvas.style.setProperty('visibility', 'visible', 'important');
        if (currentCanvas.style.opacity !== '1') currentCanvas.style.setProperty('opacity', '1', 'important');
        if (currentCanvas.style.clipPath !== 'none') {
            currentCanvas.style.setProperty('clip-path', 'none', 'important');
            currentCanvas.style.setProperty('-webkit-clip-path', 'none', 'important');
        }
        
        currentCtx.clearRect(0, 0, currentCanvas.width, currentCanvas.height);
        
        const elements = window.addedElements || addedElements || [];
        if (elements && Array.isArray(elements) && elements.length > 0) {
            elements.forEach((element) => {
                if (!element) return;
                try {
                    if (element.type === 'text' && typeof drawTextOnCanvas === 'function') {
                        drawTextOnCanvas(element.text, element.x, element.y, element.id);
                    } else if (element.type === 'shape' && typeof window.drawShape === 'function') {
                        window.drawShape(element.shapeType, element.x, element.y, element.width, element.height, element.id);
                    } else if (element.type === 'line' && typeof drawLine === 'function') {
                        drawLine(element.lineType, element.x1, element.y1, element.x2, element.y2);
                    }
                } catch (err) { console.error('Erreur dessin √©l√©ment:', err); }
            });
        }
        
        const currentSelectedElement = window.selectedElement || selectedElement;
        if (currentSelectedElement && (currentSelectedElement.type === 'shape' || currentSelectedElement.type === 'text' || currentSelectedElement.type === 'line') && typeof drawResizeHandles === 'function') {
            try { drawResizeHandles(currentSelectedElement); } catch (err) { console.error('Erreur poign√©es:', err); }
        }
    } catch (error) {
        console.error('Erreur redrawCanvas:', error);
    } finally {
        isRedrawing = false;
    }
}

// Toujours diff√©rer pour ne jamais ex√©cuter dans la pile d'un event handler (√©vite "Maximum call stack size exceeded")
let redrawCanvasScheduled = false;
window.redrawCanvas = function() {
    if (redrawCanvasScheduled) return;
    redrawCanvasScheduled = true;
    setTimeout(function() {
        redrawCanvasScheduled = false;
        redrawCanvasImpl();
    }, 0);
};

function drawResizeHandles(element) {
    const currentCtx = window.ctx || ctx;
    if (!currentCtx) return;
    
    const handleSize = 8;
    const handles = [];
    
    if (element.type === 'shape') {
        // 8 poign√©es pour les formes (coins et milieux)
        handles.push(
            {x: element.x, y: element.y}, // Coin sup√©rieur gauche
            {x: element.x + element.width/2, y: element.y}, // Milieu haut
            {x: element.x + element.width, y: element.y}, // Coin sup√©rieur droit
            {x: element.x + element.width, y: element.y + element.height/2}, // Milieu droit
            {x: element.x + element.width, y: element.y + element.height}, // Coin inf√©rieur droit
            {x: element.x + element.width/2, y: element.y + element.height}, // Milieu bas
            {x: element.x, y: element.y + element.height}, // Coin inf√©rieur gauche
            {x: element.x, y: element.y + element.height/2} // Milieu gauche
        );
    } else if (element.type === 'text') {
        const metrics = currentCtx.measureText(element.text);
        handles.push(
            {x: element.x, y: element.y},
            {x: element.x + metrics.width, y: element.y},
            {x: element.x + metrics.width, y: element.y + element.fontSize},
            {x: element.x, y: element.y + element.fontSize}
        );
    } else if (element.type === 'line') {
        handles.push({ x: element.x1, y: element.y1 });
        handles.push({ x: element.x2, y: element.y2 });
    }
    
    // Dessiner les poign√©es
    handles.forEach(handle => {
        currentCtx.fillStyle = '#4a90e2';
        currentCtx.strokeStyle = '#ffffff';
        currentCtx.lineWidth = 2;
        currentCtx.beginPath();
        currentCtx.arc(handle.x, handle.y, handleSize, 0, Math.PI * 2);
        currentCtx.fill();
        currentCtx.stroke();
    });
}

function getResizeHandleAtPosition(x, y, element) {
    if (!element) return null;
    
    const handleSize = 12;
    const handles = [];
    
    if (element.type === 'shape') {
        handles.push(
            {x: element.x, y: element.y, type: 'nw'},
            {x: element.x + element.width/2, y: element.y, type: 'n'},
            {x: element.x + element.width, y: element.y, type: 'ne'},
            {x: element.x + element.width, y: element.y + element.height/2, type: 'e'},
            {x: element.x + element.width, y: element.y + element.height, type: 'se'},
            {x: element.x + element.width/2, y: element.y + element.height, type: 's'},
            {x: element.x, y: element.y + element.height, type: 'sw'},
            {x: element.x, y: element.y + element.height/2, type: 'w'}
        );
    } else if (element.type === 'text') {
        ctx.font = `bold ${element.fontSize}px Arial`;
        const metrics = ctx.measureText(element.text);
        handles.push(
            {x: element.x, y: element.y, type: 'nw'},
            {x: element.x + metrics.width, y: element.y, type: 'ne'},
            {x: element.x + metrics.width, y: element.y + element.fontSize, type: 'se'},
            {x: element.x, y: element.y + element.fontSize, type: 'sw'}
        );
    } else if (element.type === 'line') {
        handles.push({ x: element.x1, y: element.y1, type: 'start' });
        handles.push({ x: element.x2, y: element.y2, type: 'end' });
    }
    
    for (let handle of handles) {
        const dx = x - handle.x;
        const dy = y - handle.y;
        if (Math.sqrt(dx * dx + dy * dy) <= handleSize) {
            return handle;
        }
    }
    return null;
}

function distanceToSegment(px, py, x1, y1, x2, y2) {
    const dx = x2 - x1, dy = y2 - y1;
    const len = Math.sqrt(dx * dx + dy * dy) || 1e-6;
    const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (len * len)));
    const projX = x1 + t * dx, projY = y1 + t * dy;
    return Math.sqrt((px - projX) * (px - projX) + (py - projY) * (py - projY));
}

// Convertit les coordonn√©es viewport (clientX, clientY) en coordonn√©es canvas (relatives √† l'image) pour que les objets d√©filent avec l'image
function getCanvasCoords(clientX, clientY) {
    const c = document.getElementById('editingCanvas');
    if (!c) return null;
    const r = c.getBoundingClientRect();
    return {
        x: clientX - r.left,
        y: clientY - r.top
    };
}

function getElementAtPosition(x, y) {
    const elementsArray = window.addedElements || [];
    for (let i = elementsArray.length - 1; i >= 0; i--) {
        const element = elementsArray[i];
        
        if (element.type === 'text') {
            const metrics = ctx.measureText(element.text);
            if (x >= element.x && x <= element.x + metrics.width &&
                y >= element.y && y <= element.y + element.fontSize) {
                return element;
            }
        } else if (element.type === 'shape') {
            if (x >= element.x && x <= element.x + element.width &&
                y >= element.y && y <= element.y + element.height) {
                return element;
            }
        } else if (element.type === 'line') {
            const d = distanceToSegment(x, y, element.x1, element.y1, element.x2, element.y2);
            if (d <= 15) return element;
        }
    }
    return null;
}

// Gestion des √©v√©nements de souris sur le canvas
function setupCanvasEvents() {
    if (eventsSetup) return; // √âviter les doublons d'√©v√©nements
    
    try {
        if (!canvas) {
            canvas = document.getElementById('editingCanvas');
        }
        if (!canvas) {
            return;
        }
        
        if (!ctx) {
            ctx = canvas.getContext('2d');
            if (!ctx) {
                return;
            }
        }
        
        eventsSetup = true;
    
    canvas.addEventListener('mousedown', function(e) {
        // Anti-r√©entrance : √©viter tout traitement si un mousedown est d√©j√† en cours (√©vite stack overflow)
        if (window.isHandlingCanvasMouseDown) return;
        window.isHandlingCanvasMouseDown = true;
        try {
        // V√âRIFIER D'ABORD si le canvas est activ√©
        if (!canvas || canvas.style.pointerEvents === 'none') {
            return;
        }
        
        const domElement = document.elementFromPoint(e.clientX, e.clientY);
        
        // Ignorer les clics sur les boutons, menus, et autres √©l√©ments interactifs
        if (domElement && (
            domElement.id === 'toolsBtn' ||
            domElement.id === 'saveBtn' ||
            domElement.closest('#toolsBtn') ||
            domElement.closest('#saveBtn') ||
            domElement.closest('.tools-btn') ||
            domElement.closest('.delete-btn') ||
            domElement.closest('.tools-menu') ||
            domElement.closest('.tools-overlay') ||
            domElement.closest('.shapes-submenu') ||
            domElement.closest('button') ||
            domElement.closest('input') ||
            domElement.closest('select') ||
            domElement.tagName === 'BUTTON' ||
            domElement.tagName === 'INPUT' ||
            domElement.tagName === 'SELECT'
        )) {
            // D√©sactiver le canvas pour permettre le clic sur le bouton
            canvas.style.pointerEvents = 'none';
            canvas.style.zIndex = '50';
            return; // Ignorer ce clic
        }
        
        // Coordonn√©es en espace canvas (relatives √† l'image) pour que les objets d√©filent avec la page
        const coords = getCanvasCoords(e.clientX, e.clientY);
        if (!coords) return;
        const x = coords.x;
        const y = coords.y;
        
        const currentSelected = window.selectedElement || selectedElement;
        
        if (currentSelected) {
            resizeHandle = getResizeHandleAtPosition(x, y, currentSelected);
            if (resizeHandle) {
                isResizing = true;
                if (currentSelected.type === 'line') {
                    initialElementState = {
                        x1: currentSelected.x1, y1: currentSelected.y1,
                        x2: currentSelected.x2, y2: currentSelected.y2
                    };
                } else {
                    initialElementState = {
                        x: currentSelected.x,
                        y: currentSelected.y,
                        width: currentSelected.width || (currentSelected.type === 'text' ? ctx.measureText(currentSelected.text).width : 0),
                        height: currentSelected.height || (currentSelected.type === 'text' ? currentSelected.fontSize : 0)
                    };
                }
                startX = x;
                startY = y;
                return;
            }
        }
        
        const clickedElement = getElementAtPosition(x, y);
        
        if (clickedElement && !isTextMode && !currentShape && !isDrawMode && !isMarkerMode && !currentLineType) {
            selectedElement = clickedElement;
            window.selectedElement = clickedElement;
            isMoving = true;
            if (clickedElement.type === 'line') {
                initialLineMoveState = { x1: clickedElement.x1, y1: clickedElement.y1, x2: clickedElement.x2, y2: clickedElement.y2 };
            } else {
                offsetX = x - clickedElement.x;
                offsetY = y - clickedElement.y;
            }
            canvas.style.cursor = 'move';
            // Diff√©rer pour √©viter "Maximum call stack size exceeded" au clic sur une forme
            setTimeout(function() {
                if (typeof redrawCanvas === 'function') redrawCanvas();
                if (typeof updateCanvasPointerEvents === 'function') updateCanvasPointerEvents();
            }, 0);
        } else if (!isTextMode && !currentShape && !isDrawMode && !isMarkerMode && !isEraserMode && !currentLineType) {
            // D√©s√©lectionner si on clique ailleurs
            selectedElement = null;
            window.selectedElement = null; // Synchroniser avec window
            // Diff√©rer pour √©viter r√©cursion
            setTimeout(function() {
                if (typeof redrawCanvas === 'function') redrawCanvas();
                if (typeof updateCanvasPointerEvents === 'function') updateCanvasPointerEvents();
            }, 0);
        } else if (isTextMode) {
            // Placer le texte √† la position cliqu√©e
            if (currentText) {
                drawTextOnCanvas(currentText, x, y);
                redrawCanvas();
            }
        } else if (isDrawMode || isMarkerMode || isEraserMode) {
            // Commencer √† dessiner, colorier ou effacer
            isDrawing = true;
            lastX = x;
            lastY = y;
            
            // Pour le feutre, colorier imm√©diatement au clic
            if (isMarkerMode) {
                ctx.globalCompositeOperation = 'multiply';
                ctx.fillStyle = currentDrawColor;
                ctx.globalAlpha = 0.3;
                ctx.beginPath();
                ctx.arc(x, y, currentBrushSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
                ctx.globalCompositeOperation = 'source-over';
            } else if (isEraserMode) {
                // Mode gomme - effacer avec destination-out
                ctx.globalCompositeOperation = 'destination-out';
                ctx.beginPath();
                ctx.arc(x, y, currentBrushSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalCompositeOperation = 'source-over';
            }
        } else if (currentLineType) {
            isDrawing = true;
            startX = x;
            startY = y;
        }
        } finally {
            setTimeout(function() { window.isHandlingCanvasMouseDown = false; }, 0);
        }
    });
    
    canvas.addEventListener('mousemove', function(e) {
        if (canvas.style.pointerEvents === 'none') return;
        
        // Coordonn√©es en espace canvas (relatives √† l'image)
        const coords = getCanvasCoords(e.clientX, e.clientY);
        if (!coords) return;
        const currentX = coords.x;
        const currentY = coords.y;
        
        const currentSelectedForResize = window.selectedElement || selectedElement;
        
        if (isResizing && currentSelectedForResize && resizeHandle && initialElementState) {
            // Redimensionner l'√©l√©ment
            const dx = currentX - startX;
            const dy = currentY - startY;
            
            if (currentSelectedForResize.type === 'shape') {
                switch(resizeHandle.type) {
                    case 'nw':
                        currentSelectedForResize.x = initialElementState.x + dx;
                        currentSelectedForResize.y = initialElementState.y + dy;
                        currentSelectedForResize.width = initialElementState.width - dx;
                        currentSelectedForResize.height = initialElementState.height - dy;
                        break;
                    case 'n':
                        currentSelectedForResize.y = initialElementState.y + dy;
                        currentSelectedForResize.height = initialElementState.height - dy;
                        break;
                    case 'ne':
                        currentSelectedForResize.y = initialElementState.y + dy;
                        currentSelectedForResize.width = initialElementState.width + dx;
                        currentSelectedForResize.height = initialElementState.height - dy;
                        break;
                    case 'e':
                        currentSelectedForResize.width = initialElementState.width + dx;
                        break;
                    case 'se':
                        currentSelectedForResize.width = initialElementState.width + dx;
                        currentSelectedForResize.height = initialElementState.height + dy;
                        break;
                    case 's':
                        currentSelectedForResize.height = initialElementState.height + dy;
                        break;
                    case 'sw':
                        currentSelectedForResize.x = initialElementState.x + dx;
                        currentSelectedForResize.width = initialElementState.width - dx;
                        currentSelectedForResize.height = initialElementState.height + dy;
                        break;
                    case 'w':
                        currentSelectedForResize.x = initialElementState.x + dx;
                        currentSelectedForResize.width = initialElementState.width - dx;
                        break;
                }
                
                // Limiter la taille minimale
                if (currentSelectedForResize.width < 20) currentSelectedForResize.width = 20;
                if (currentSelectedForResize.height < 20) currentSelectedForResize.height = 20;
                
                // Synchroniser avec window.selectedElement et window.addedElements
                window.selectedElement = currentSelectedForResize;
                selectedElement = currentSelectedForResize;
                const elementsArray = window.addedElements || [];
                const elementIndex = elementsArray.findIndex(el => el.id === currentSelectedForResize.id);
                if (elementIndex !== -1) {
                    elementsArray[elementIndex] = currentSelectedForResize;
                    window.addedElements = elementsArray;
                }
            } else if (currentSelectedForResize.type === 'text') {
                const scale = 1 + (dx / 100);
                currentSelectedForResize.fontSize = Math.max(12, Math.min(72, initialElementState.height * scale));
                window.selectedElement = currentSelectedForResize;
                selectedElement = currentSelectedForResize;
                const elementsArray = window.addedElements || [];
                const elementIndex = elementsArray.findIndex(el => el.id === currentSelectedForResize.id);
                if (elementIndex !== -1) {
                    elementsArray[elementIndex] = currentSelectedForResize;
                    window.addedElements = elementsArray;
                }
            } else if (currentSelectedForResize.type === 'line') {
                if (resizeHandle.type === 'start') {
                    currentSelectedForResize.x1 = currentX;
                    currentSelectedForResize.y1 = currentY;
                } else if (resizeHandle.type === 'end') {
                    currentSelectedForResize.x2 = currentX;
                    currentSelectedForResize.y2 = currentY;
                }
                window.selectedElement = currentSelectedForResize;
                selectedElement = currentSelectedForResize;
                const elementsArray = window.addedElements || [];
                const elementIndex = elementsArray.findIndex(el => el.id === currentSelectedForResize.id);
                if (elementIndex !== -1) {
                    elementsArray[elementIndex] = currentSelectedForResize;
                    window.addedElements = elementsArray;
                }
            }
            
            redrawCanvas();
            return;
        }
        
        // D√©placement
        const currentSelectedForMove = window.selectedElement || selectedElement;
        if (isMoving && currentSelectedForMove) {
            const dx = currentX - startX;
            const dy = currentY - startY;
            
            if (currentSelectedForMove.type === 'line' && initialLineMoveState) {
                currentSelectedForMove.x1 = initialLineMoveState.x1 + dx;
                currentSelectedForMove.y1 = initialLineMoveState.y1 + dy;
                currentSelectedForMove.x2 = initialLineMoveState.x2 + dx;
                currentSelectedForMove.y2 = initialLineMoveState.y2 + dy;
            } else {
                currentSelectedForMove.x = currentX - offsetX;
                currentSelectedForMove.y = currentY - offsetY;
            }
            
            window.selectedElement = currentSelectedForMove;
            selectedElement = currentSelectedForMove;
            const elementsArray = window.addedElements || [];
            const elementIndex = elementsArray.findIndex(el => el.id === currentSelectedForMove.id);
            if (elementIndex !== -1) {
                elementsArray[elementIndex] = currentSelectedForMove;
                window.addedElements = elementsArray;
            }
            redrawCanvas();
            return;
        }
        
        if (!isDrawing) {
            // V√©rifier si on survole une poign√©e de redimensionnement
            const currentSelectedForHover = window.selectedElement || selectedElement;
            if (currentSelectedForHover) {
                const handle = getResizeHandleAtPosition(currentX, currentY, currentSelectedForHover);
                if (handle) {
                    const cursors = {
                        'nw': 'nw-resize', 'n': 'n-resize', 'ne': 'ne-resize',
                        'e': 'e-resize', 'se': 'se-resize', 's': 's-resize',
                        'sw': 'sw-resize', 'w': 'w-resize',
                        'start': 'nw-resize', 'end': 'se-resize'
                    };
                    canvas.style.cursor = cursors[handle.type] || 'default';
                    return;
                }
            }
            
            // V√©rifier si on survole un √©l√©ment pour changer le curseur
            const hoveredElement = getElementAtPosition(currentX, currentY);
            if (hoveredElement && !isTextMode && !currentShape && !isDrawMode && !isMarkerMode && !isEraserMode && !currentLineType) {
                canvas.style.cursor = 'move';
            } else if (isTextMode) {
                canvas.style.cursor = 'text';
            } else if (currentShape || currentLineType || isDrawMode || isMarkerMode || isEraserMode) {
                canvas.style.cursor = isEraserMode ? 'grab' : 'crosshair';
            } else {
                canvas.style.cursor = 'default';
            }
            return;
        }
        
        if (isDrawMode) {
            // Dessiner librement avec crayon
            ctx.strokeStyle = currentDrawColor;
            ctx.lineWidth = currentBrushSize;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(currentX, currentY);
            ctx.stroke();
            
            lastX = currentX;
            lastY = currentY;
        } else if (isMarkerMode) {
            // Colorier avec feutre (mode remplissage semi-transparent)
            ctx.globalCompositeOperation = 'multiply';
            ctx.fillStyle = currentDrawColor;
            ctx.globalAlpha = 0.3;
            
            ctx.beginPath();
            ctx.arc(currentX, currentY, currentBrushSize, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.globalAlpha = 1.0;
            ctx.globalCompositeOperation = 'source-over';
            
            lastX = currentX;
            lastY = currentY;
        } else if (isEraserMode) {
            // Mode gomme - effacer avec destination-out
            ctx.globalCompositeOperation = 'destination-out';
            ctx.beginPath();
            ctx.arc(currentX, currentY, currentBrushSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalCompositeOperation = 'source-over';
            
            lastX = currentX;
            lastY = currentY;
        } else if (currentLineType) {
            // Redessiner le canvas pour les lignes seulement
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawLine(currentLineType, startX, startY, currentX, currentY);
        }
    });
    
    canvas.addEventListener('mouseup', function(e) {
        // V√©rifier que le canvas est activ√©
        if (canvas.style.pointerEvents === 'none') {
            return;
        }
        
        if (isResizing) {
            isResizing = false;
            resizeHandle = null;
            initialElementState = null;
        }
        
        if (isMoving) {
            isMoving = false;
            initialLineMoveState = null;
            canvas.style.cursor = 'default';
        }
        
        if (isDrawing) {
            isDrawing = false;
        }
    });
    
    canvas.addEventListener('mouseleave', function(e) {
        if (isResizing) {
            isResizing = false;
            resizeHandle = null;
            initialElementState = null;
        }
        
        if (isMoving) {
            isMoving = false;
            initialLineMoveState = null;
        }
        
        if (isDrawing) {
            isDrawing = false;
        }
    });
    
    // Gestion du zoom avec la molette de souris pour les formes s√©lectionn√©es
    canvas.addEventListener('wheel', function(e) {
        // V√©rifier que le canvas est activ√©
        if (canvas.style.pointerEvents === 'none') {
            return;
        }
        
        // V√©rifier qu'une forme est s√©lectionn√©e
        const currentSelectedElement = window.selectedElement || selectedElement;
        if (!currentSelectedElement || currentSelectedElement.type !== 'shape') {
            return;
        }
        
        // Emp√™cher le scroll de la page
        e.preventDefault();
        
        // Calculer le facteur de zoom (agrandir ou r√©duire)
        const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1; // R√©duire si scroll vers le bas, agrandir si vers le haut
        
        // Calculer le centre de la forme
        const centerX = currentSelectedElement.x + currentSelectedElement.width / 2;
        const centerY = currentSelectedElement.y + currentSelectedElement.height / 2;
        
        // Calculer les nouvelles dimensions
        const newWidth = Math.max(20, currentSelectedElement.width * zoomFactor);
        const newHeight = Math.max(20, currentSelectedElement.height * zoomFactor);
        
        // Ajuster la position pour garder le centre fixe
        currentSelectedElement.x = centerX - newWidth / 2;
        currentSelectedElement.y = centerY - newHeight / 2;
        currentSelectedElement.width = newWidth;
        currentSelectedElement.height = newHeight;
        
        // Synchroniser avec window.selectedElement
        window.selectedElement = currentSelectedElement;
        selectedElement = currentSelectedElement;
        
        // Mettre √† jour l'√©l√©ment dans window.addedElements
        const elementsArray = window.addedElements || [];
        const elementIndex = elementsArray.findIndex(el => el.id === currentSelectedElement.id);
        if (elementIndex !== -1) {
            elementsArray[elementIndex] = currentSelectedElement;
            window.addedElements = elementsArray;
        }
        
        // Redessiner le canvas
        redrawCanvas();
    }, { passive: false });
    
    // Gestion du menu contextuel (clic droit)
    canvas.addEventListener('contextmenu', function(e) {
        // V√©rifier que le canvas est activ√©
        if (canvas.style.pointerEvents === 'none') {
            return;
        }
        
        // V√©rifier si on clique sur un bouton
        const clickedElement = document.elementFromPoint(e.clientX, e.clientY);
        if (clickedElement && (
            clickedElement.closest('.tools-btn') ||
            clickedElement.closest('.delete-btn') ||
            clickedElement.closest('.tools-menu') ||
            clickedElement.closest('button')
        )) {
            return; // Ignorer
        }
        
        e.preventDefault();
        
        const coords = getCanvasCoords(e.clientX, e.clientY);
        if (!coords) return;
        const x = coords.x;
        const y = coords.y;
        
        const elementAtPosition = getElementAtPosition(x, y);
        
        if (elementAtPosition && (elementAtPosition.type === 'shape' || elementAtPosition.type === 'text' || elementAtPosition.type === 'line')) {
            selectedElement = elementAtPosition;
            window.selectedElement = elementAtPosition;
            setTimeout(function() {
                if (typeof redrawCanvas === 'function') redrawCanvas();
            }, 0);
            
            // Afficher le menu contextuel
            const contextMenu = document.getElementById('contextMenu');
            if (contextMenu) {
                contextMenu.style.display = 'block';
                contextMenu.style.left = e.clientX + 'px';
                contextMenu.style.top = e.clientY + 'px';
            }
        } else {
            // Masquer le menu si on clique ailleurs
            hideContextMenu();
        }
    });
    
    // Masquer le menu contextuel si on clique ailleurs
    document.addEventListener('click', function(e) {
        if (!e.target.closest('.context-menu')) {
            hideContextMenu();
        }
    });
    } catch (error) {
        console.error('Erreur lors de la configuration des √©v√©nements du canvas:', error);
    }
}

function hideContextMenu() {
    const contextMenu = document.getElementById('contextMenu');
    if (contextMenu) {
        contextMenu.style.display = 'none';
    }
}

function deleteSelectedElement() {
    const currentSelected = window.selectedElement || selectedElement;
    if (currentSelected) {
        // Trouver l'index de l'√©l√©ment dans le tableau
        const elementsArray = window.addedElements || [];
        const index = elementsArray.findIndex(el => el.id === currentSelected.id);
        if (index !== -1) {
            // Supprimer l'√©l√©ment
            elementsArray.splice(index, 1);
            window.addedElements = elementsArray;
            selectedElement = null;
            window.selectedElement = null;
            hideContextMenu();
            redrawCanvas();
            updateCanvasPointerEvents(); // Mettre √† jour l'√©tat du canvas
        }
    }
}

// Initialiser le canvas quand la page est charg√©e
document.addEventListener('DOMContentLoaded', function() {
    try {
        // S'assurer que le bouton "Outils" est TOUJOURS cliquable
        const toolsBtn = document.getElementById('toolsBtn');
        
        if (toolsBtn) {
            // FORCER les styles pour garantir que le bouton est au-dessus
            toolsBtn.style.cssText += 'z-index: 10001 !important; pointer-events: auto !important; position: relative !important;';
            
            // D√©sactiver le canvas par d√©faut pour ne pas bloquer le bouton
            if (canvas) {
                canvas.style.pointerEvents = 'none';
                canvas.style.zIndex = '50';
            }
            
            // Fonction pour forcer le clic
            function handleToolsClick(e) {
                // Emp√™cher TOUTE propagation
                if (e.stopPropagation) e.stopPropagation();
                if (e.stopImmediatePropagation) e.stopImmediatePropagation();
                if (e.preventDefault) e.preventDefault();
                
                // D√©sactiver le canvas IMM√âDIATEMENT
                if (canvas) {
                    canvas.style.pointerEvents = 'none';
                    canvas.style.zIndex = '50';
                }
                
                // Appeler la fonction directement - v√©rifier qu'elle existe
                console.log('handleToolsClick appel√©'); // Debug
                if (typeof toggleToolsMenu === 'function') {
                    console.log('toggleToolsMenu existe, appel...'); // Debug
                    toggleToolsMenu();
                } else {
                    console.error('toggleToolsMenu n\'est pas une fonction');
                    // Essayer d'appeler directement
                    const menu = document.getElementById('toolsMenu');
                    if (menu) {
                        menu.classList.toggle('active');
                        const overlay = document.getElementById('toolsOverlay');
                        if (overlay) overlay.classList.toggle('active');
                    }
                }
                
                return false;
            }
            
            // D√©sactiver le canvas par d√©faut pour ne pas bloquer le bouton
            // Le canvas sera r√©activ√© uniquement quand n√©cessaire (formes s√©lectionn√©es, etc.)
            if (canvas) {
                canvas.style.pointerEvents = 'none';
                canvas.style.zIndex = '50';
            }
            
            // D√©sactiver le canvas quand on survole le bouton
            toolsBtn.addEventListener('mouseenter', function() {
                if (canvas) {
                    canvas.style.pointerEvents = 'none';
                    canvas.style.zIndex = '50';
                }
            });
            
            // R√©activer le canvas quand on quitte le bouton (sauf si le menu est ouvert)
            toolsBtn.addEventListener('mouseleave', function() {
                const menu = document.getElementById('toolsMenu');
                const isMenuOpen = menu && menu.classList.contains('active');
                if (canvas && !isMenuOpen) {
                    // Ne r√©activer le canvas que si une forme est s√©lectionn√©e
                    const hasSelectedElement = window.selectedElement || (window.addedElements && window.addedElements.length > 0);
                    if (hasSelectedElement) {
                        canvas.style.pointerEvents = 'auto';
                        canvas.style.zIndex = '100';
                    }
                }
            });
            
            // Gestion du bouton "Sauvegarder"
            const saveBtn = document.getElementById('saveBtn');
            if (saveBtn) {
                saveBtn.style.cssText += 'z-index: 10001 !important; pointer-events: auto !important; position: relative !important;';
                
                saveBtn.addEventListener('mouseenter', function() {
                    if (canvas) {
                        canvas.style.pointerEvents = 'none';
                        canvas.style.zIndex = '50';
                    }
                });
                
                saveBtn.addEventListener('mouseleave', function() {
                    const menu = document.getElementById('toolsMenu');
                    const isMenuOpen = menu && menu.classList.contains('active');
                    if (canvas && !isMenuOpen) {
                        const hasSelectedElement = window.selectedElement || (window.addedElements && window.addedElements.length > 0);
                        if (hasSelectedElement) {
                            canvas.style.pointerEvents = 'auto';
                            canvas.style.zIndex = '100';
                        }
                    }
                });
            }
        } else {
            // Si le bouton n'existe pas, le canvas peut √™tre activ√© par d√©faut
            if (canvas) {
                canvas.style.pointerEvents = 'none';
                canvas.style.zIndex = '50';
            }
        }
        
        // Tracker la position de la souris pour updateCanvasPointerEvents
        if (!window.mouseX) {
            document.addEventListener('mousemove', function(e) {
                window.mouseX = e.clientX;
                window.mouseY = e.clientY;
                // Mettre √† jour le canvas en temps r√©el
                if (canvas) {
                    updateCanvasPointerEvents();
                }
            }, true);
        }
        
        // V√©rifier que l'image existe avant d'initialiser
        const imageElement = document.getElementById('editableImage');
        if (!imageElement) {
            console.log('Pas d\'image √† √©diter');
            return;
        }
        
        // Attendre un peu que tout soit charg√©
        setTimeout(function() {
            try {
                initCanvas();
                setupCanvasEvents();
            } catch (error) {
                console.error('Erreur lors de l\'initialisation du canvas:', error);
            }
        }, 300);
        
        window.addEventListener('resize', function() {
            try {
                // Mettre √† jour la taille du canvas pour couvrir tout l'√©cran
                if (canvas && window.innerWidth > 0 && window.innerHeight > 0) {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    resizeCanvas();
                }
            } catch (error) {
                console.error('Erreur lors du redimensionnement:', error);
            }
        });
    } catch (error) {
        console.error('Erreur lors de l\'initialisation:', error);
    }
});

// Script de d√©bogage - √† supprimer en production
window.testShapes = function() {
    console.log('=== TEST DES FORMES ===');
    console.log('window.selectShape:', typeof window.selectShape);
    console.log('window.canvas:', !!window.canvas, window.canvas ? {
        width: window.canvas.width,
        height: window.canvas.height,
        style: {
            display: window.canvas.style.display,
            visibility: window.canvas.style.visibility,
            zIndex: window.canvas.style.zIndex,
            pointerEvents: window.canvas.style.pointerEvents
        }
    } : null);
    console.log('window.ctx:', !!window.ctx);
    console.log('window.drawShape:', typeof window.drawShape);
    console.log('window.redrawCanvas:', typeof window.redrawCanvas);
    console.log('window.addedElements:', window.addedElements ? window.addedElements.length : 0, window.addedElements);
    
    const canvas = document.getElementById('editingCanvas');
    console.log('Canvas DOM:', !!canvas, canvas ? {
        width: canvas.width,
        height: canvas.height,
        style: {
            display: canvas.style.display,
            visibility: canvas.style.visibility,
            zIndex: canvas.style.zIndex,
            pointerEvents: canvas.style.pointerEvents,
            clipPath: canvas.style.clipPath
        }
    } : null);
    
    const image = document.getElementById('editableImage');
    console.log('Image:', !!image, image ? {
        width: image.naturalWidth,
        height: image.naturalHeight,
        rect: image.getBoundingClientRect()
    } : null);
    
    if (typeof window.selectShape === 'function') {
        console.log('Test: Appel de selectShape("square")...');
        window.selectShape('square');
    } else {
        console.error('window.selectShape n\'est pas une fonction!');
    }
};

// Fonction de test pour v√©rifier le dessin directement
window.testDrawShape = function() {
    console.log('=== TEST DRAW SHAPE DIRECT ===');
    const canvas = document.getElementById('editingCanvas');
    const ctx = canvas ? canvas.getContext('2d') : null;
    
    if (!canvas || !ctx) {
        console.error('Canvas ou contexte non disponible');
        return;
    }
    
    // Forcer la visibilit√©
    canvas.style.setProperty('display', 'block', 'important');
    canvas.style.setProperty('visibility', 'visible', 'important');
    canvas.style.setProperty('opacity', '1', 'important');
    canvas.style.setProperty('clip-path', 'none', 'important');
    
    // S'assurer que le canvas a une taille
    if (canvas.width === 0 || canvas.height === 0) {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    
    // Dessiner un carr√© de test au centre
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;
    const size = 100;
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#FFD700';
    ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
    ctx.lineWidth = 3;
    ctx.fillRect(centerX - size/2, centerY - size/2, size, size);
    ctx.strokeRect(centerX - size/2, centerY - size/2, size, size);
    
    console.log('‚úÖ Carr√© de test dessin√© au centre:', {centerX, centerY, size});
    console.log('Si vous voyez un carr√© jaune au centre, le canvas fonctionne!');
};
</script>
{% endblock %}
